{"pages":[{"title":"","text":"å”è‰ºæ˜• ææ² æä¸€æ¡ gakki å›¾ç‰‡æœé›†äºäº’è”ç½‘ï¼Œä¾µæƒè¯·ç•™è¨€ï¼Œé©¬ä¸Šå¤„ç†ğŸ˜Šã€‚","link":"/album/index.html"},{"title":"éŸ³ä¹æ­Œå•æ”¶è—","text":"æ¸©é¦¨æç¤ºï¼šé€‰æ‹©å–œæ¬¢çš„éŸ³ä¹åŒå‡»æ’­æ”¾ï¼Œç”±äºç‰ˆæƒåŸå› éƒ¨åˆ†ä¸èƒ½æ’­æ”¾ã€‚å¦‚æœå–œæ¬¢æ­Œå•æ”¶è—ä¸€ä¸‹ï¼Œå»ç½‘æ˜“äº‘éƒ½èƒ½æ’­æ”¾å“Ÿï¼","link":"/music/index.html"},{"title":"","text":"ä¸ªäººç®€ä»‹ åˆ†äº«ä¸»é¢˜ä½œè€…å’Œæˆ‘éƒ½å¾ˆå–œæ¬¢çš„è€ç½—çš„ä¸€æ®µè¯ï¼š â€œæ¯ä¸€ä¸ªç”Ÿå‘½æ¥åˆ°ä¸–é—´éƒ½æ³¨å®šæ”¹å˜ä¸–ç•Œï¼Œåˆ«æ— é€‰æ‹©ã€‚è¦ä¹ˆå˜å¾—å¥½ä¸€ç‚¹ï¼Œè¦ä¹ˆå˜å¾—åä¸€ç‚¹ã€‚ä½ å¦‚æœèµ°è¿›ç¤¾ä¼šä¸ºäº†ç”Ÿå­˜ä¸ºäº†ä»€ä¹ˆä¸è¦è„¸çš„ç†ç”±ï¼Œå˜æˆäº†ä¸€ä¸ªæ¶å¿ƒçš„æˆå¹´äººç¤¾ä¼šä¸­çš„ä¸€å‘˜ï¼Œé‚£ä½ å°±æŠŠè¿™ä¸ªä¸–ç•Œå˜å¾—æ¶å¿ƒäº†ä¸€ç‚¹ç‚¹ã€‚å¦‚æœä½ ä¸€ç”Ÿåˆšæ­£ä¸é˜¿ï¼Œå¦‚æœä½ ä¸€ç”Ÿè€¿ç›´ï¼Œæ²¡æœ‰åšä»»ä½•æ¶å¿ƒçš„äº‹æƒ…ï¼Œæ²¡åšå¯¹åˆ«äººæœ‰å®³çš„äº‹æƒ…ï¼Œä¸€è¾ˆå­æ‹¼äº†è€å‘½å‹‰å¼ºæŠŠè‡ªå·±èº«è¾¹çš„å‡ ä¸ªäººç…§é¡¾å¥½äº†ï¼Œæ²¡æœ‰æˆåæ²¡æœ‰å‘è´¢ï¼Œæ²¡æœ‰æˆå°±ä¼Ÿå¤§çš„äº‹ä¸šï¼Œç„¶åè€¿ç€è„–å­ä¸€ç”Ÿæ­£ç›´ï¼Œåˆ°äº†ä¸ƒå…«åå²è€¿ç€è„–å­å»ä¸–äº†ã€‚ä½ è¿™ä¸€ç”Ÿæ˜¯ä¸æ˜¯æ²¡æœ‰æ”¹å˜ä¸–ç•Œï¼Ÿä½ è¿˜æ˜¯æ”¹å˜ä¸–ç•Œäº†ï¼Œä½ æŠŠè¿™ä¸ªä¸–ç•Œå˜å¾—ç¾å¥½äº†ä¸€ç‚¹ç‚¹ã€‚å› ä¸ºä¸–ç•Œä¸Šåˆå¤šäº†ä¸€ä¸ªå¥½äººã€‚â€ å–„æ¶ç»ˆæœ‰æŠ¥ï¼Œå¤©é“å¥½è½®å›ã€‚ä¸ä¿¡æŠ¬å¤´çœ‹ï¼Œè‹å¤©é¥¶è¿‡è°ã€‚æ— è®ºä½•æ—¶ä½•åœ°ï¼Œæˆ‘ä»¬éƒ½è¦ä¿æŒä¸€é¢—ç§¯æä¹è§‚ã€å–„è‰¯æ„Ÿæ©çš„å¿ƒã€‚ä½†è¡Œå¥½äº‹è«é—®å‰ç¨‹ï¼Œæ°¸è¿œå¹´è½»ï¼Œæ°¸è¿œçƒ­å†…ç›ˆçœ¶ï¼Œæ°¸è¿œä¿æŒæ­£èƒ½é‡ã€‚ğŸ’ªğŸ’ªğŸ’ªğŸ’ªğŸ’ªğŸ’ªå†²é¸­ï¼ï¼ï¼ï¼ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;ä¸ªäººä¿¡æ¯ï¼šé€šä¿¡å·¥ç¨‹ä¸“ä¸šä»äº‹JAVAåç«¯å¼€å‘åšä¿¡ä»£ç æ”¹å˜ä¸–ç•Œ åšå®¢ä¿¡æ¯ ç½‘ç«™é‡‡ç”¨çš„Amazingä¸»é¢˜ è¿½æ±‚å°½å¯èƒ½çš„ç®€æ´ï¼Œæ¸…æ™°ï¼Œæ˜“ç”¨ã€‚ æ„Ÿè°¢ä¸»é¢˜ä½œè€…çš„åˆ†äº«ã€‚ æœ¬ç«™æ¨èç´¢å¼• æŠ€æœ¯çŸ¥è¯†ç‚¹ Javaå¹¶å‘çŸ¥è¯†ç‚¹ æ³•å¾‹æ³•è§„ æ³•å¾‹æ³•è§„æ•°æ®åº“ ä¸­åäººæ°‘å…±å’Œå›½å›½æ——æ³• ä¸­åäººæ°‘å…±å’Œå›½å®ªæ³• ä¸­åäººæ°‘å…±å’Œå›½æ¶ˆè´¹è€…æƒç›Šä¿æŠ¤æ³• ä¸­åäººæ°‘å…±å’Œå›½åˆ‘äº‹è¯‰è®¼æ³• ä¸­åäººæ°‘å…±å’Œå›½å©šå§»æ³• ä¸­åäººåå…±å’Œå›½ç½‘ç»œå®‰å…¨æ³• ä¸­åäººæ°‘å…±å’Œå›½åŠ³åŠ¨æ³• å…¶ä»– è®¡åˆ’2020è®¡åˆ’ 2019.12.31 2020-GOALS è·‘ä¸¤ä¸‰åœºé©¬æ‹‰æ¾ 2019è®¡åˆ’ 2018.12.31/21:59:00-&gt;æ›´æ–°äº2019.12.31 2019-GOALS è´­ä¹°çš„ä¸“ä¸šä¹¦ç±è‡³å°‘çœ‹å®Œä¸€éï¼ˆå¹¶å‘ã€é‡æ„ã€è®¾è®¡æ¨¡å¼â€¦ï¼‰-&gt; 95% é¢å¤–ï¼š è¿½äº†å¾ˆå¤šå‰§ æ€»ç»“ï¼š æœ‰ä¼˜ç‚¹æœ‰ç¼ºç‚¹ï¼Œæ²¡åšæŒä¸‹æ¥çš„è¿˜æ˜¯å¤ªå¤šï¼Œè¿½äº†å¤ªå¤šå‰§ã€‚ä»¥åå¤šå­¦ä¹ ï¼Œå¤šæ€è€ƒï¼ æ—¶é—´è½´è®°å½•","link":"/about/index.html"},{"title":"","text":"æ¥è€Œä¸å¾€éç¤¼ä¹Ÿç•…æ‰€æ¬²è¨€ï¼Œæœ‰ç•™å¿…åº”","link":"/message/index.html"},{"title":"","text":"&nbsp;&nbsp;å¬å¬éŸ³ä¹ éŸ³ä¹æ’­æ”¾å™¨ç”±mePlayeræä¾›ï¼Œå¸ƒå±€å‚ç…§ç½‘å‹åšå®¢æ‰€ä½œï¼Œæ„Ÿè°¢ä½œè€…çš„è¾›å‹¤ä»˜å‡ºã€‚æ›´å¤šéŸ³ä¹åˆ†äº«è¯·æŸ¥çœ‹æ­Œå•ã€‚ &nbsp;&nbsp;çœ‹çœ‹è§†é¢‘ ->ç‚¹å‡»ä»¥ä¸‹æ¡ç›®å¼€å§‹æ’­æ”¾è§†é¢‘,å‘ä¸‹æ»‘åŠ¨æŸ¥çœ‹æ›´å¤š","link":"/media/index.html"},{"title":"","text":"ç”³è¯·å‹é“¾é¡»çŸ¥ åŸåˆ™ä¸Šåªå’ŒæŠ€æœ¯ç±»åšå®¢äº¤æ¢ï¼Œä½†ä¸åŒ…æ‹¬å«æœ‰å’Œè‰²æƒ…ã€æš´åŠ›ã€æ”¿æ²»æ•æ„Ÿçš„ç½‘ç«™ã€‚ ä¸å’Œå‰½çªƒã€ä¾µæƒã€æ— è¯šä¿¡çš„ç½‘ç«™äº¤æ¢ï¼Œä¼˜å…ˆå’Œå…·æœ‰åŸåˆ›ä½œå“çš„ç½‘ç«™äº¤æ¢ã€‚ ç”³è¯·è¯·æä¾›ï¼šç«™ç‚¹åç§°ã€ç«™ç‚¹é“¾æ¥ã€ç«™ç‚¹æè¿°ã€logoæˆ–å¤´åƒï¼ˆä¸è¦è®¾ç½®é˜²ç›—é“¾ï¼‰ã€‚ æ’åä¸åˆ†å…ˆåï¼Œåˆ·æ–°åé‡æ’ï¼Œæ›´æ–°ä¿¡æ¯åè¯·ç•™è¨€å‘ŠçŸ¥ã€‚ ä¼šå®šæœŸæ¸…ç†å¾ˆä¹…å¾ˆä¹…ä¸æ›´æ–°çš„ã€ä¸ç¬¦åˆè¦æ±‚çš„å‹é“¾ï¼Œä¸å†å¦è¡Œé€šçŸ¥ã€‚ æœ¬ç«™ä¸å­˜å‚¨å‹é“¾å›¾ç‰‡ï¼Œå¦‚æœå‹é“¾å›¾ç‰‡æ¢äº†æ— æ³•æ›´æ–°ã€‚å›¾ç‰‡è£‚äº†çš„ä¼šæ›¿æ¢æˆé»˜è®¤å›¾ï¼Œéœ€è¦æ›´æ¢çš„è¯·ç•™è¨€å‘ŠçŸ¥ã€‚ æœ¬ç«™å‹é“¾ä¿¡æ¯å¦‚ä¸‹ï¼Œç”³è¯·å‹é“¾å‰è¯·å…ˆæ·»åŠ æœ¬ç«™ä¿¡æ¯ï¼š ç½‘ç«™å›¾æ ‡ï¼šhttps://hellosyl.github.io/img/avatar.png ç½‘ç«™åç§°ï¼šhellosyl ç½‘ç«™åœ°å€ï¼šhttps://hellosyl.github.io ç½‘ç«™ç®€ä»‹ï¼šåç«¯å¼€å‘ï¼ŒæŠ€æœ¯åˆ†äº« åŠ è½½ä¸­ï¼Œç¨ç­‰å‡ ç§’...","link":"/friend/index.html"},{"title":"","text":"ç¢ç¢å¿µ tipsï¼šgithubç™»å½•åæŒ‰æ—¶é—´æ­£åºæŸ¥çœ‹ã€å¯ç‚¹èµåŠ â¤ï¸ã€æœ¬æ’ä»¶åœ°å€..ã€Œ+99æ¬¡æŸ¥çœ‹ã€ ç¢ç¢å¿µåŠ è½½ä¸­ï¼Œè¯·ç¨ç­‰... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: 'b57588205e5c0f76a733', clientSecret: '7d5b4255e5babcbca5471ec05f79c63373cae2da', id: '666666', repo: 'hellosyl.github.io', owner: 'hellosyl', admin: \"hellosyl\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"Hello World","text":"å—¨ï¼Œè¯·å‡†ç¡®æ— è¯¯åœ°è¾“å…¥å¯†ç æŸ¥çœ‹å“Ÿï¼ 56d7b3367aa49e28656be8eed6581cbf75773aa16885176585bd5c2aad635ab9a897bf7e71f3718a47fd258431908e462684af0fbb97dffc44a06260b190ff2c5e6267321d624658d160fc0a0a038f9e740079012223467b14d7c3039b31e35c767c8d711ca3e2e236e583d9d2cad26a46554b6313a7c9f693826598602815a71a666110adc5d1a3b96b74850f4877b0ae70ba4acaaf37089c638adfb08d94345e3d54a06892901812c8c063b3a6c15027e7a62e238bac400460cde1c3dbe9c4a3909d85fa2b622f9f0f14f335307973545d29dc853d66bf1823bcc002d3709a7c147f34f3c0175b18b7cc2d5e4716aeda4bdb4436d8af3053044e837eff035f83959d45bc76b986e17e2d6b27f8ba1553b42de3af3ec10c285bb378e78b188bdeee1472e7aaad3eed9dae4db725312eb61306678ce3d0c954daeeadc92e0b82e6964008ed4215345fbae64f539ab1a1271a3d91baa701211ae16025a4350ab5463500fb5b88ae3ebd17fe4524c9f02bb261623f7eaee682cdd82b77e3c412911667106c7f9c0f882e002e611263fec52521bdbb34de651e4ee8023370ebe6ac0d22185e5cec7b3f74cc28f30fa3e2d3120a7cbde26c9079d0527eb65b0b03681ecce7a6302452db599bc454ade4f18a5fe1ca1e41f6a42ab7a8448845aa82337b8cf8f8b07c0a521b2360c4741253845c5f467efb20764a2078d8c5fc2af1ec386ddc2a5dd0f6528513db2204f8848694025aaea1f219e58febd856014d01006dc132e18fd5a104d520c8ca609b7e48dbd3adabe44b930aae454b48a39cc112ac528f1a1e04187de5e0afd58eb8cbacce6fc9094a8002a678fa109099d6fd4e5cf1227f01b90687730a6a760073196396f38ac47475bf6d6ce51ec064513ea3525a92181005230fbbb18d0220194f691c24ecf381a6d44fd115c924cc8a938829fb85274eb367e05fe92d2e7c58595ff94c324585a1b67045eea8a75d70f93e9cab3df483616089daca6361cf560692b3ab82484e418905f7a4a53566be06719a73a8f1ee5a4a27223a4e7177e100cfc7f156980f15f49b400daa31550db2275fd2ca7419eb4a90fe49169e80fc12dfa4da6c14c4e8c52207b8a701cfe061c0a1f323cd8519b2847f8193375b10b59ed727cd11ab5657178b3d2230929b578795f7671ec8e41a56cf68884219e381d035ef92bf2fc3a6b18177449485bd50660e7f6c7822505079b03bd7d2e324d6dd5d9623fc2b20ce594933163f4e85399f1fddec3a3839d5d5cd136b5dcde39d3a021ad6cbcc878d44457dcb85dea0afd52037349180a1b239065532d8b3f22038ca2fa6a8b4dacb3380237ea9666156f24b363a976e4c886279d3e5cdd5c68468845665537d01cb84b59a08570d4c9aa27af38731aa3f16206a92bed8b295d7dc66bf2132e0e29de8a7a450dd9dfc3b6cabaac181911848cd04d10655dbeb1b13d5448a21a9e601bbee937f372a5409ec83c3e9bbc164d7902b8190907689a65f458c8807f43b7ade334bc899fef49c88689b6d2fc22839f738f33753a9040688c317fffa246027794ab9f612880f2177978f1f2f68228831f2a83cb63decc33dc7a230b75fac6bceac156ab09a74dad7e0117a2671265ab80dbf002738263b91197f2b9a33ecfe9486a06918fd3fb5598b8978854b8191c5673e081bd5d67403899ffddb741367df41a7a23611aa4283eaeca9ae998f82651ec263bcf32e50c42002d7519335739587c8a9cf5c3cfffba301dd6fbaa7e85790938aca4927da772da6ee85c4b8d1f48b70dc35a860cead0a8ff61d6a012f622960fcad7685211eec888f4f0a488087cd17843d2770ac8118df9c69acc716c27da2f9e9fc2e2c7a9c2d1d2ed3e8561b56fd821230f85b0857ff37b744ad933e2a2f9d2877a5021b6a976ddb6f8f9edd81d965efb8d32d846bd862a73ccfb4325d9a871b2173f74ce85824e9a13a6f7747a5ab9b570854fc3993e0f7715bc1c7d652590a3fe24f00c055bf3717df5742d442ec05355e24c28c4b9e8fa64b09eb35a2ec8f184e06c16c0aff229b8b6cd38ca8d210fc6af274d7205dab47c1b577625c78e3b234fc42c1006080b0cb45a6f677aeba1a955bf4e6233b16cfc516166c621fc148885c9c1a6bbb18512f60c3f941bc1316d1957ee6d21d6b3cf9e181cf0e5ed1d0fb813d135dadac35b56a712483bf44770d9b279baf618c8b4aee263af207bbb9abe0d13eb5783c6952f508ea84713b4b4913b313c6e88a3a7c9b0bae9f0ca3a0980a72c1af2470d66aa49f6b6501c04096d17123a78f16e77dea2df71d12af930372014c4e28ab32455340a0630e145b3153dabe3c598f024497bbf8d241cd63fc088485999bcb2d719e98008476fe31d9cddf85414e49614861593877247db84de4874abbca390b702ef201c3aa6ef3539859973ccdfd18267057041fb05f1d51c3a3811ca15edce73679f8a33388ea6b87c013f2d76ea4d25b4302bf009611dd430130ffb1a78554d5fbffd034d2e741c063c9a869f8b9196072c416bf3c6460f7a653963a058dd196a7128df2c9f8adf2b2726e5744859a9c0b556efeb40eeef1319c9814c8aefa562f6cd1964cdc918cb17ad4190f54246170da67dd41adf717fbcf1dad0ae65ddd48681fcb890b0bff90b089ed3c9c504609ddaca5096f7f77a462b5a9531e861aa52aeadc13ec79cd4f085bd83f6b615532c7feb52442b1bbbea8f83ad2fa9c356586147652c7b263769e4aeeaf4fb2691d48309dbdcfb23ab1b0ba70d115a482a4065c3f22ef30365dff05239ebccee69969f9bf9a954dfafa6848a7691a30eb36d57ca83bc6232433ff6f5c6c149d13ea3732c0783d64b1592febe51a21c726080109a52e5a3fd21e503b77d5f11325cc6912488158c29ebff450affcd29414a8f2f1711a6344916759ee22bbea85c6746f18f38eb5f0873125d3e4955b3fbbe36613d52e445d2fb235e04443542b93619a55910df35401fb5c9617f3cbfdb375324a9a9cc05d230feae07d413c92e67e6e14a5da05dcec5cf448878d84327621b9c75f6a9b5102b31640c478edc4bcdb7fd2b7c02cba1033a105b09fb115a14ca89baec469e1ae80dcdeca89201fce46d5f2391cc31fb9be","link":"/2020/09/30/hello-world/"},{"title":"test","text":"è¿™æ˜¯æµ‹è¯•â€¦. ä¸€ã€â€¦. äºŒã€ â€¦. ä¸‰ã€","link":"/2020/10/01/online-utils/"},{"title":"TCPä¸UDP","text":"ã€å°šæœªå®Œç»“ã€‘ ä¸€ã€äº’è”ç½‘çš„åŸºçŸ³1ã€ç½‘ç»œåè®®åŠæ¨¡å‹è®¡ç®—æœºä¸ç½‘ç»œè®¾å¤‡è¦ç›¸äº’é€šä¿¡ï¼ŒåŒæ–¹å°±å¿…é¡»åŸºäºç›¸åŒçš„æ–¹æ³•ã€‚æ¯”å¦‚ï¼Œå¦‚ä½•æ¢æµ‹åˆ°é€šä¿¡ç›®æ ‡ã€ç”±å“ªä¸€è¾¹å…ˆå‘èµ·é€šä¿¡ã€ä½¿ç”¨å“ªç§è¯­è¨€è¿›è¡Œé€šä¿¡ã€æ€æ ·ç»“æŸé€šä¿¡ç­‰è§„åˆ™éƒ½éœ€è¦äº‹å…ˆç¡®å®šã€‚ä¸åŒçš„ç¡¬ä»¶ã€æ“ä½œç³»ç»Ÿä¹‹é—´çš„é€šä¿¡ï¼Œæ‰€æœ‰çš„è¿™ä¸€åˆ‡éƒ½éœ€è¦ä¸€ç§è§„åˆ™ã€‚è€Œæˆ‘ä»¬å°±æŠŠè¿™ç§è§„åˆ™ç§°ä¸ºåè®®ï¼ˆprotocolï¼‰ã€‚ç½‘ç»œåè®®æœ‰å¾ˆå¤šï¼ŒæŒ‰ç…§åŠŸèƒ½ä¸åŒï¼Œåˆ†å·¥ä¸åŒï¼Œäººä»¬äººä¸ºçš„å°†å…¶è¿›è¡Œäº†åˆ†å±‚ï¼Œæ›´ä¾¿äºç†è§£ã€‚ä¾‹å¦‚OSIä¸ƒå±‚æ¨¡å‹ï¼ŒTCP/IPå››å±‚æ¨¡å‹ã€‚å®é™…ä¸Šè¿™ä¸ªä¸ƒå±‚å››å±‚æ˜¯ä¸å­˜åœ¨çš„ï¼Œåªæ˜¯äººä¸ºçš„åˆ’åˆ†çš„æ¦‚å¿µï¼ŒåŒºåˆ†å‡ºæ¥çš„ç›®çš„åªæ˜¯è®©ä½ æ˜ç™½å“ªä¸€å±‚æ˜¯å¹²ä»€ä¹ˆç”¨çš„ã€‚ OSIï¼šå¼€æ”¾å¼ç³»ç»Ÿäº’è”é€šä¿¡å‚è€ƒæ¨¡å‹ï¼ˆè‹±è¯­ï¼šOpen System Interconnection Reference Modelï¼Œç¼©å†™ä¸º OSIï¼‰ï¼Œç®€ç§°ä¸º OSI æ¨¡å‹ï¼ˆOSI modelï¼‰ï¼Œä¸€ç§æ¦‚å¿µæ¨¡å‹ï¼Œç”±å›½é™…æ ‡å‡†åŒ–ç»„ç»‡æå‡ºï¼Œä¸€ä¸ªè¯•å›¾ä½¿å„ç§è®¡ç®—æœºåœ¨ä¸–ç•ŒèŒƒå›´å†…äº’è¿ä¸ºç½‘ç»œçš„æ ‡å‡†æ¡†æ¶ã€‚å®šä¹‰äºISO/IEC 7498-1ã€‚ TCP/IPï¼šï¼ˆTransmission Control Protocol/Internet Protocolï¼Œä¼ è¾“æ§åˆ¶åè®®/ç½‘é™…åè®®ï¼‰æ˜¯æŒ‡èƒ½å¤Ÿåœ¨å¤šä¸ªä¸åŒç½‘ç»œé—´å®ç°ä¿¡æ¯ä¼ è¾“çš„åè®®ç°‡ã€‚ TCPã€UDPã€IPã€FTPã€HTTPã€ICMPã€SMTP ç­‰éƒ½å±äº TCP/IP æ—å†…çš„åè®®ï¼Œ åªæ˜¯å› ä¸ºåœ¨ TCP/IP åè®®ä¸­ TCP åè®®å’Œ IP åè®®æœ€å…·ä»£è¡¨æ€§ï¼Œæ‰€ä»¥è¢«ç§°ä¸º TCP/IP åè®®ã€‚è¿™äº›åè®®å¯ä»¥åˆ’åˆ†ä¸ºå››å±‚ï¼Œåˆ†åˆ«ä¸ºé“¾è·¯å±‚ã€ç½‘ç»œå±‚ã€ä¼ è¾“å±‚å’Œåº”ç”¨å±‚ã€‚ 2ã€TCPå’ŒUDPä¸‹å›¾å±•ç¤ºäº†åˆ†å±‚æ¨¡å‹ï¼š å¦‚å›¾æ‰€ç¤ºï¼ŒTCPå’ŒUDPéƒ½æ˜¯ä¼ è¾“å±‚åè®®ï¼Œåœ¨ã€ŠOSIä¸ƒå±‚ç½‘ç»œåè®®è¯¦è§£ã€‹ä¸€æ–‡ä¸­è¯¦ç»†çš„è®²è§£äº†å„ä¸ªåˆ†å±‚åœ¨ç½‘ç»œä¼ è¾“ä¸­çš„ä½œç”¨åŠåŸç†ã€‚ ä¼ è¾“å±‚æä¾›é€»è¾‘è¿æ¥çš„å»ºç«‹ã€ä¼ è¾“å±‚å¯»å€ã€æ•°æ®ä¼ è¾“ã€ä¼ è¾“è¿æ¥é‡Šæ”¾ã€æµé‡æ§åˆ¶ã€æ‹¥å¡æ§åˆ¶ã€å¤šè·¯å¤ç”¨å’Œè§£å¤ç”¨ã€å´©æºƒæ¢å¤ç­‰æœåŠ¡ã€‚ äºŒã€TCP1ã€TCPçš„æ¦‚å¿µ å½“ä¸€å°è®¡ç®—æœºæƒ³è¦ä¸å¦ä¸€å°è®¡ç®—æœºé€šè®¯æ—¶ï¼Œä¸¤å°è®¡ç®—æœºä¹‹é—´çš„é€šä¿¡éœ€è¦ç•…é€šä¸”å¯é ï¼Œè¿™æ ·æ‰èƒ½ä¿è¯æ­£ç¡®æ”¶å‘æ•°æ®ã€‚ä¾‹å¦‚ï¼Œå½“ä½ æƒ³æŸ¥çœ‹ç½‘é¡µæˆ–æŸ¥çœ‹ç”µå­é‚®ä»¶æ—¶ï¼Œå¸Œæœ›å®Œæ•´ä¸”æŒ‰é¡ºåºæŸ¥çœ‹ç½‘é¡µï¼Œè€Œä¸ä¸¢å¤±ä»»ä½•å†…å®¹ã€‚å½“ä½ ä¸‹è½½æ–‡ä»¶æ—¶ï¼Œå¸Œæœ›è·å¾—çš„æ˜¯å®Œæ•´çš„æ–‡ä»¶ï¼Œè€Œä¸ä»…ä»…æ˜¯æ–‡ä»¶çš„ä¸€éƒ¨åˆ†ï¼Œå› ä¸ºå¦‚æœæ•°æ®ä¸¢å¤±æˆ–ä¹±åºï¼Œéƒ½ä¸æ˜¯ä½ å¸Œæœ›å¾—åˆ°çš„ç»“æœï¼Œäºæ˜¯å°±ç”¨åˆ°äº† TCPã€‚ TCPåè®®å…¨ç§°æ˜¯ï¼ˆTransmission Control Protocolï¼‰ä¼ è¾“æ§åˆ¶åè®®æ˜¯ä¸€ç§é¢å‘è¿æ¥çš„ã€å¯é çš„ã€å…¨åŒå·¥é€šä¿¡çš„ã€åŸºäºå­—èŠ‚æµçš„ä¼ è¾“å±‚é€šä¿¡åè®®ã€‚ 2ã€TCPæŠ¥æ–‡ç»“æ„ æŠ¥æ–‡æ•´ä½“ TCPé¦–éƒ¨ tcp flags çŠ¶æ€æ§åˆ¶ç ï¼Œå  6 æ¯”ç‰¹ä½ï¼Œå«ä¹‰å¦‚ä¸‹ï¼š URGï¼šç´§æ€¥æ¯”ç‰¹ï¼ˆurgentï¼‰ï¼Œå½“ URGï¼1 æ—¶ï¼Œè¡¨æ˜ç´§æ€¥æŒ‡é’ˆå­—æ®µæœ‰æ•ˆï¼Œä»£è¡¨è¯¥å°åŒ…ä¸ºç´§æ€¥å°åŒ…ã€‚å®ƒå‘Šè¯‰ç³»ç»Ÿæ­¤æŠ¥æ–‡æ®µä¸­æœ‰ç´§æ€¥æ•°æ®ï¼Œåº”å°½å¿«ä¼ é€(ç›¸å½“äºé«˜ä¼˜å…ˆçº§çš„æ•°æ®)ï¼Œ ä¸”ä¸Šå›¾ä¸­çš„ Urgent Pointer å­—æ®µä¹Ÿä¼šè¢«å¯ç”¨ã€‚ ACKï¼šç¡®è®¤æ¯”ç‰¹ï¼ˆAcknowledgeï¼‰ã€‚åªæœ‰å½“ ACKï¼1 æ—¶ç¡®è®¤å·å­—æ®µæ‰æœ‰æ•ˆï¼Œä»£è¡¨è¿™ä¸ªå°åŒ…ä¸ºç¡®è®¤å°åŒ…ã€‚å½“ ACKï¼0 æ—¶ï¼Œç¡®è®¤å·æ— æ•ˆã€‚ PSHï¼šï¼ˆPush functionï¼‰è‹¥ä¸º 1 æ—¶ï¼Œä»£è¡¨è¦æ±‚å¯¹æ–¹ï¼ˆæ¥æ”¶ç«¯ï¼‰ç«‹å³ä¼ é€ç¼“å†²åŒºå†…çš„å…¶ä»–å¯¹åº”å°åŒ…ï¼Œè€Œæ— éœ€ç­‰ç¼“å†²æ»¡äº†æ‰é€ã€‚ RSTï¼šå¤ä½æ¯”ç‰¹(Reset)ï¼Œå½“ RSTï¼1 æ—¶ï¼Œè¡¨æ˜ TCP è¿æ¥ä¸­å‡ºç°ä¸¥é‡å·®é”™ï¼ˆå¦‚ç”±äºä¸»æœºå´©æºƒæˆ–å…¶ä»–åŸå› ï¼‰ï¼Œå¿…é¡»é‡Šæ”¾è¿æ¥ï¼Œç„¶åå†é‡æ–°å»ºç«‹è¿è¾“è¿æ¥ã€‚ SYNï¼šåŒæ­¥æ¯”ç‰¹(Synchronous)ï¼ŒSYN ç½®ä¸º 1ï¼Œå°±è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªè¿æ¥è¯·æ±‚æˆ–è¿æ¥æ¥å—æŠ¥æ–‡ï¼Œé€šå¸¸å¸¦æœ‰ SYN æ ‡å¿—çš„å°åŒ…è¡¨ç¤ºã€ä¸»åŠ¨ã€è¦è¿æ¥åˆ°å¯¹æ–¹çš„æ„æ€ã€‚ FINï¼šç»ˆæ­¢æ¯”ç‰¹(Final)ï¼Œç”¨æ¥é‡Šæ”¾ä¸€ä¸ªè¿æ¥ã€‚å½“ FINï¼1 æ—¶ï¼Œè¡¨æ˜æ­¤æŠ¥æ–‡æ®µçš„å‘é€ç«¯çš„æ•°æ®å·²å‘é€å®Œæ¯•ï¼Œå¹¶è¦æ±‚é‡Šæ”¾ä¼ è¾“è¿æ¥ã€‚ åºåˆ—å·ï¼ˆå°å†™å•è¯æ˜¯åºåˆ—å·ï¼Œå¤§å†™å•è¯æ˜¯çŠ¶æ€æ§åˆ¶ç é0åŠ1ï¼‰ åºå·seqï¼šå 4ä¸ªå­—èŠ‚ï¼Œç”¨æ¥æ ‡è®°æ•°æ®æ®µçš„é¡ºåºï¼ŒTCPæŠŠè¿æ¥ä¸­å‘é€çš„æ‰€æœ‰æ•°æ®å­—èŠ‚éƒ½ç¼–ä¸Šä¸€ä¸ªåºå·ï¼Œç¬¬ä¸€ä¸ªå­—èŠ‚çš„ç¼–å·ç”±æœ¬åœ°éšæœºäº§ç”Ÿï¼›ç»™å­—èŠ‚ç¼–ä¸Šåºå·åï¼Œå°±ç»™æ¯ä¸€ä¸ªæŠ¥æ–‡æ®µæŒ‡æ´¾ä¸€ä¸ªåºå·ï¼›åºåˆ—å·seqå°±æ˜¯è¿™ä¸ªæŠ¥æ–‡æ®µä¸­çš„ç¬¬ä¸€ä¸ªå­—èŠ‚çš„æ•°æ®ç¼–å·ã€‚ ç¡®è®¤å·ackï¼šå 4ä¸ªå­—èŠ‚ï¼ŒæœŸå¾…æ”¶åˆ°å¯¹æ–¹ä¸‹ä¸€ä¸ªæŠ¥æ–‡æ®µçš„ç¬¬ä¸€ä¸ªæ•°æ®å­—èŠ‚çš„åºå·ï¼›åºåˆ—å·è¡¨ç¤ºæŠ¥æ–‡æ®µæºå¸¦æ•°æ®çš„ç¬¬ä¸€ä¸ªå­—èŠ‚çš„ç¼–å·ï¼›è€Œç¡®è®¤å·æŒ‡çš„æ˜¯æœŸæœ›æ¥æ”¶åˆ°ä¸‹ä¸€ä¸ªå­—èŠ‚çš„ç¼–å·ï¼›å› æ­¤å½“å‰æŠ¥æ–‡æ®µæœ€åä¸€ä¸ªå­—èŠ‚çš„ç¼–å·+1å³ä¸ºç¡®è®¤å·ã€‚ 3ã€TCPçš„è¿æ¥è¿‡ç¨‹ TCP æ˜¯é¢å‘è¿æ¥çš„ï¼Œæ— è®ºå“ªä¸€æ–¹å‘å¦ä¸€æ–¹å‘é€æ•°æ®ä¹‹å‰ï¼Œéƒ½å¿…é¡»å…ˆåœ¨åŒæ–¹ä¹‹é—´å»ºç«‹ä¸€æ¡è¿æ¥ã€‚åœ¨ TCP/IP åè®®ä¸­ï¼ŒTCP åè®®æä¾›å¯é çš„è¿æ¥æœåŠ¡ï¼Œè¿æ¥æ˜¯é€šè¿‡ä¸‰æ¬¡æ¡æ‰‹è¿›è¡Œåˆå§‹åŒ–çš„ã€‚ä¸‰æ¬¡æ¡æ‰‹çš„ç›®çš„æ˜¯åŒæ­¥è¿æ¥åŒæ–¹çš„åºåˆ—å·å’Œç¡®è®¤å·å¹¶äº¤æ¢ TCP çª—å£å¤§å°ä¿¡æ¯ã€‚è¿™å°±æ˜¯é¢è¯•ä¸­ç»å¸¸ä¼šè¢«é—®åˆ°çš„ TCP ä¸‰æ¬¡æ¡æ‰‹ã€‚åªæ˜¯äº†è§£ TCP ä¸‰æ¬¡æ¡æ‰‹çš„æ¦‚å¿µï¼Œå¯¹ä½ è·å¾—ä¸€ä»½å·¥ä½œæ˜¯æ²¡æœ‰ä»»ä½•å¸®åŠ©çš„ï¼Œä½ éœ€è¦å»äº†è§£ TCP ä¸‰æ¬¡æ¡æ‰‹ä¸­çš„ä¸€äº›ç»†èŠ‚ã€‚å…ˆæ¥çœ‹å›¾è¯´è¯ã€‚ 3.1 TCP ä¸‰æ¬¡æ¡æ‰‹ ç¬¬ä¸€æ¬¡æ¡æ‰‹ï¼šå»ºç«‹è¿æ¥ã€‚å®¢æˆ·ç«¯å‘é€è¿æ¥è¯·æ±‚æŠ¥æ–‡æ®µï¼Œå°† SYN ä½ç½®ä¸º1ï¼Œseqï¼ˆsequence numberï¼‰ä¸º xï¼›ç„¶åï¼Œå®¢æˆ·ç«¯è¿›å…¥ SYN_SENT çŠ¶æ€ï¼Œç­‰å¾…æœåŠ¡å™¨çš„ç¡®è®¤ï¼› ç¬¬äºŒæ¬¡æ¡æ‰‹ï¼šæœåŠ¡å™¨æ”¶åˆ° SYN æŠ¥æ–‡æ®µã€‚æœåŠ¡å™¨æ”¶åˆ°å®¢æˆ·ç«¯çš„ SYN æŠ¥æ–‡æ®µï¼Œéœ€è¦å¯¹è¿™ä¸ª SYN æŠ¥æ–‡æ®µè¿›è¡Œç¡®è®¤ï¼Œè®¾ç½® acknowledgment number ä¸º x+1(sequence number+1)ï¼›åŒæ—¶ï¼Œè‡ªå·±è‡ªå·±è¿˜è¦å‘é€ SYN è¯·æ±‚ä¿¡æ¯ï¼Œå°† SYN ä½ç½®ä¸º1ï¼Œsequence numberä¸ºyï¼›æœåŠ¡å™¨ç«¯å°†ä¸Šè¿°æ‰€æœ‰ä¿¡æ¯æ”¾åˆ°ä¸€ä¸ªæŠ¥æ–‡æ®µï¼ˆå³ SYN+ACK æŠ¥æ–‡æ®µï¼‰ä¸­ï¼Œä¸€å¹¶å‘é€ç»™å®¢æˆ·ç«¯ï¼Œæ­¤æ—¶æœåŠ¡å™¨è¿›å…¥ SYN_RECV çŠ¶æ€ï¼› ç¬¬ä¸‰æ¬¡æ¡æ‰‹ï¼šå®¢æˆ·ç«¯æ”¶åˆ°æœåŠ¡å™¨çš„ SYN+ACK æŠ¥æ–‡æ®µã€‚ç„¶åå°† acknowledgment number è®¾ç½®ä¸º y+1ï¼Œå‘æœåŠ¡å™¨å‘é€ ACK æŠ¥æ–‡æ®µï¼Œè¿™ä¸ªæŠ¥æ–‡æ®µå‘é€å®Œæ¯•ä»¥åï¼Œå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯éƒ½è¿›å…¥ ESTABLISHED çŠ¶æ€ï¼Œå®Œæˆ TCP ä¸‰æ¬¡æ¡æ‰‹ã€‚ 3.2 TCP å››æ¬¡æŒ¥æ‰‹ ç¬¬ä¸€æ¬¡åˆ†æ‰‹ï¼šä¸»æœº1ï¼ˆå¯ä»¥ä½¿å®¢æˆ·ç«¯ï¼Œä¹Ÿå¯ä»¥æ˜¯æœåŠ¡å™¨ç«¯ï¼‰ï¼Œè®¾ç½® sequence number å’Œ acknowledgment numberï¼Œå‘ä¸»æœº2å‘é€ä¸€ä¸ªFINæŠ¥æ–‡æ®µï¼›æ­¤æ—¶ï¼Œä¸»æœº1è¿›å…¥ FIN_WAIT_1 çŠ¶æ€ï¼›è¿™è¡¨ç¤ºä¸»æœº1æ²¡æœ‰æ•°æ®è¦å‘é€ç»™ä¸»æœº2äº†ï¼› ç¬¬äºŒæ¬¡åˆ†æ‰‹ï¼šä¸»æœº2æ”¶åˆ°äº†ä¸»æœº1å‘é€çš„FINæŠ¥æ–‡æ®µï¼Œå‘ä¸»æœº1å›ä¸€ä¸ª ACK æŠ¥æ–‡æ®µï¼Œacknowledgment number ä¸º sequence number åŠ 1ï¼›ä¸»æœº1è¿›å…¥FIN_WAIT_2çŠ¶æ€ï¼›ä¸»æœº2å‘Šè¯‰ä¸»æœº1ï¼Œæˆ‘â€œåŒæ„â€ä½ çš„å…³é—­è¯·æ±‚ï¼› ç¬¬ä¸‰æ¬¡åˆ†æ‰‹ï¼šä¸»æœº2å‘ä¸»æœº1å‘é€FINæŠ¥æ–‡æ®µï¼Œè¯·æ±‚å…³é—­è¿æ¥ï¼ŒåŒæ—¶ä¸»æœº2è¿›å…¥LAST_ACKçŠ¶æ€ï¼› ç¬¬å››æ¬¡åˆ†æ‰‹ï¼šä¸»æœº1æ”¶åˆ°ä¸»æœº2å‘é€çš„ FIN æŠ¥æ–‡æ®µï¼Œå‘ä¸»æœº2å‘é€ ACK æŠ¥æ–‡æ®µï¼Œç„¶åä¸»æœº1è¿›å…¥ TIME_WAIT çŠ¶æ€ï¼›ä¸»æœº2æ”¶åˆ°ä¸»æœº1çš„ ACK æŠ¥æ–‡æ®µä»¥åï¼Œå°±å…³é—­è¿æ¥ï¼›æ­¤æ—¶ï¼Œä¸»æœº1ç­‰å¾…2MSLåä¾ç„¶æ²¡æœ‰æ”¶åˆ°å›å¤ï¼Œåˆ™è¯æ˜ Server ç«¯å·²æ­£å¸¸å…³é—­ï¼Œé‚£å¥½ï¼Œä¸»æœº1ä¹Ÿå¯ä»¥å…³é—­è¿æ¥äº†ã€‚ 3.3 TCP ä¸ºä»€ä¹ˆè¦ä¸‰æ¬¡æ¡æ‰‹ ä¸ºäº†é˜²æ­¢å·²å¤±æ•ˆçš„è¿æ¥è¯·æ±‚æŠ¥æ–‡æ®µçªç„¶åˆä¼ é€åˆ°äº†æœåŠ¡ç«¯ï¼Œå› è€Œäº§ç”Ÿé”™è¯¯ã€‚ å·²å¤±æ•ˆçš„è¿æ¥è¯·æ±‚æŠ¥æ–‡æ®µçš„äº§ç”Ÿåœ¨è¿™æ ·ä¸€ç§æƒ…å†µä¸‹ï¼šclient å‘å‡ºçš„ç¬¬ä¸€ä¸ªè¿æ¥è¯·æ±‚æŠ¥æ–‡æ®µå¹¶æ²¡æœ‰ä¸¢å¤±ï¼Œè€Œæ˜¯åœ¨æŸä¸ªç½‘ç»œç»“ç‚¹é•¿æ—¶é—´çš„æ»ç•™äº†ï¼Œä»¥è‡´å»¶è¯¯åˆ°è¿æ¥é‡Šæ”¾ä»¥åçš„æŸä¸ªæ—¶é—´æ‰åˆ°è¾¾ serverã€‚æœ¬æ¥è¿™æ˜¯ä¸€ä¸ªæ—©å·²å¤±æ•ˆçš„æŠ¥æ–‡æ®µã€‚ä½† server æ”¶åˆ°æ­¤å¤±æ•ˆçš„è¿æ¥è¯·æ±‚æŠ¥æ–‡æ®µåï¼Œå°±è¯¯è®¤ä¸ºæ˜¯ client å†æ¬¡å‘å‡ºçš„ä¸€ä¸ªæ–°çš„è¿æ¥è¯·æ±‚ã€‚äºæ˜¯å°±å‘ client å‘å‡ºç¡®è®¤æŠ¥æ–‡æ®µï¼ŒåŒæ„å»ºç«‹è¿æ¥ã€‚å‡è®¾ä¸é‡‡ç”¨ä¸‰æ¬¡æ¡æ‰‹ï¼Œé‚£ä¹ˆåªè¦ server å‘å‡ºç¡®è®¤ï¼Œæ–°çš„è¿æ¥å°±å»ºç«‹äº†ã€‚ç”±äºç°åœ¨ client å¹¶æ²¡æœ‰å‘å‡ºå»ºç«‹è¿æ¥çš„è¯·æ±‚ï¼Œå› æ­¤ä¸ä¼šç†ç¬ server çš„ç¡®è®¤ï¼Œä¹Ÿä¸ä¼šå‘ server å‘é€æ•°æ®ã€‚ä½† server å´ä»¥ä¸ºæ–°çš„è¿è¾“è¿æ¥å·²ç»å»ºç«‹ï¼Œå¹¶ä¸€ç›´ç­‰å¾… client å‘æ¥æ•°æ®ã€‚è¿™æ ·ï¼Œserver çš„å¾ˆå¤šèµ„æºå°±ç™½ç™½æµªè´¹æ‰äº†ã€‚é‡‡ç”¨ä¸‰æ¬¡æ¡æ‰‹çš„åŠæ³•å¯ä»¥é˜²æ­¢ä¸Šè¿°ç°è±¡å‘ç”Ÿã€‚ä¾‹å¦‚åˆšæ‰é‚£ç§æƒ…å†µï¼Œclient ä¸ä¼šå‘ server çš„ç¡®è®¤å‘å‡ºç¡®è®¤ã€‚server ç”±äºæ”¶ä¸åˆ°ç¡®è®¤ï¼Œå°±çŸ¥é“ client å¹¶æ²¡æœ‰è¦æ±‚å»ºç«‹è¿æ¥ã€‚ 3.4 TCP ä¸ºä»€ä¹ˆè¦å››æ¬¡æŒ¥æ‰‹ é‚£å››æ¬¡åˆ†æ‰‹åˆæ˜¯ä¸ºä½•å‘¢ï¼ŸTCPåè®®æ˜¯ä¸€ç§é¢å‘è¿æ¥çš„ã€å¯é çš„ã€åŸºäºå­—èŠ‚æµçš„è¿è¾“å±‚é€šä¿¡åè®®ã€‚TCPæ˜¯å…¨åŒå·¥æ¨¡å¼ï¼Œè¿™å°±æ„å‘³ç€ï¼Œå½“ä¸»æœº1å‘å‡ºFINæŠ¥æ–‡æ®µæ—¶ï¼Œåªæ˜¯è¡¨ç¤ºä¸»æœº1å·²ç»æ²¡æœ‰æ•°æ®è¦å‘é€äº†ï¼Œä¸»æœº1å‘Šè¯‰ä¸»æœº2ï¼Œå®ƒçš„æ•°æ®å·²ç»å…¨éƒ¨å‘é€å®Œæ¯•äº†ï¼›ä½†æ˜¯ï¼Œè¿™ä¸ªæ—¶å€™ä¸»æœº1è¿˜æ˜¯å¯ä»¥æ¥å—æ¥è‡ªä¸»æœº2çš„æ•°æ®ï¼›å½“ä¸»æœº2è¿”å›ACKæŠ¥æ–‡æ®µæ—¶ï¼Œè¡¨ç¤ºå®ƒå·²ç»çŸ¥é“ä¸»æœº1æ²¡æœ‰æ•°æ®å‘é€äº†ï¼Œä½†æ˜¯ä¸»æœº2è¿˜æ˜¯å¯ä»¥å‘é€æ•°æ®åˆ°ä¸»æœº1çš„ï¼›å½“ä¸»æœº2ä¹Ÿå‘é€äº†FINæŠ¥æ–‡æ®µæ—¶ï¼Œè¿™ä¸ªæ—¶å€™å°±è¡¨ç¤ºä¸»æœº2ä¹Ÿæ²¡æœ‰æ•°æ®è¦å‘é€äº†ï¼Œå°±ä¼šå‘Šè¯‰ä¸»æœº1ï¼Œæˆ‘ä¹Ÿæ²¡æœ‰æ•°æ®è¦å‘é€äº†ï¼Œä¹‹åå½¼æ­¤å°±ä¼šæ„‰å¿«çš„ä¸­æ–­è¿™æ¬¡TCPè¿æ¥ã€‚å¦‚æœè¦æ­£ç¡®çš„ç†è§£å››æ¬¡åˆ†æ‰‹çš„åŸç†ï¼Œå°±éœ€è¦äº†è§£å››æ¬¡åˆ†æ‰‹è¿‡ç¨‹ä¸­çš„çŠ¶æ€å˜åŒ–ã€‚ FIN_WAIT_1: è¿™ä¸ªçŠ¶æ€è¦å¥½å¥½è§£é‡Šä¸€ä¸‹ï¼Œå…¶å®FIN_WAIT_1å’ŒFIN_WAIT_2çŠ¶æ€çš„çœŸæ­£å«ä¹‰éƒ½æ˜¯è¡¨ç¤ºç­‰å¾…å¯¹æ–¹çš„FINæŠ¥æ–‡ã€‚è€Œè¿™ä¸¤ç§çŠ¶æ€çš„åŒºåˆ«æ˜¯ï¼šFIN_WAIT_1çŠ¶æ€å®é™…ä¸Šæ˜¯å½“SOCKETåœ¨ESTABLISHEDçŠ¶æ€æ—¶ï¼Œå®ƒæƒ³ä¸»åŠ¨å…³é—­è¿æ¥ï¼Œå‘å¯¹æ–¹å‘é€äº†FINæŠ¥æ–‡ï¼Œæ­¤æ—¶è¯¥SOCKETå³è¿›å…¥åˆ°FIN_WAIT_1çŠ¶æ€ã€‚è€Œå½“å¯¹æ–¹å›åº”ACKæŠ¥æ–‡åï¼Œåˆ™è¿›å…¥åˆ°FIN_WAIT_2çŠ¶æ€ï¼Œå½“ç„¶åœ¨å®é™…çš„æ­£å¸¸æƒ…å†µä¸‹ï¼Œæ— è®ºå¯¹æ–¹ä½•ç§æƒ…å†µä¸‹ï¼Œéƒ½åº”è¯¥é©¬ä¸Šå›åº”ACKæŠ¥æ–‡ï¼Œæ‰€ä»¥FIN_WAIT_1çŠ¶æ€ä¸€èˆ¬æ˜¯æ¯”è¾ƒéš¾è§åˆ°çš„ï¼Œè€ŒFIN_WAIT_2çŠ¶æ€è¿˜æœ‰æ—¶å¸¸å¸¸å¯ä»¥ç”¨netstatçœ‹åˆ°ã€‚ï¼ˆä¸»åŠ¨æ–¹ï¼‰FIN_WAIT_2ï¼šä¸Šé¢å·²ç»è¯¦ç»†è§£é‡Šäº†è¿™ç§çŠ¶æ€ï¼Œå®é™…ä¸ŠFIN_WAIT_2çŠ¶æ€ä¸‹çš„SOCKETï¼Œè¡¨ç¤ºåŠè¿æ¥ï¼Œä¹Ÿå³æœ‰ä¸€æ–¹è¦æ±‚closeè¿æ¥ï¼Œä½†å¦å¤–è¿˜å‘Šè¯‰å¯¹æ–¹ï¼Œæˆ‘æš‚æ—¶è¿˜æœ‰ç‚¹æ•°æ®éœ€è¦ä¼ é€ç»™ä½ (ACKä¿¡æ¯)ï¼Œç¨åå†å…³é—­è¿æ¥ã€‚ï¼ˆä¸»åŠ¨æ–¹ï¼‰CLOSE_WAITï¼šè¿™ç§çŠ¶æ€çš„å«ä¹‰å…¶å®æ˜¯è¡¨ç¤ºåœ¨ç­‰å¾…å…³é—­ã€‚æ€ä¹ˆç†è§£å‘¢ï¼Ÿå½“å¯¹æ–¹closeä¸€ä¸ªSOCKETåå‘é€FINæŠ¥æ–‡ç»™è‡ªå·±ï¼Œä½ ç³»ç»Ÿæ¯«æ— ç–‘é—®åœ°ä¼šå›åº”ä¸€ä¸ªACKæŠ¥æ–‡ç»™å¯¹æ–¹ï¼Œæ­¤æ—¶åˆ™è¿›å…¥åˆ°CLOSE_WAITçŠ¶æ€ã€‚æ¥ä¸‹æ¥å‘¢ï¼Œå®é™…ä¸Šä½ çœŸæ­£éœ€è¦è€ƒè™‘çš„äº‹æƒ…æ˜¯å¯Ÿçœ‹ä½ æ˜¯å¦è¿˜æœ‰æ•°æ®å‘é€ç»™å¯¹æ–¹ï¼Œå¦‚æœæ²¡æœ‰çš„è¯ï¼Œé‚£ä¹ˆä½ ä¹Ÿå°±å¯ä»¥ closeè¿™ä¸ªSOCKETï¼Œå‘é€FINæŠ¥æ–‡ç»™å¯¹æ–¹ï¼Œä¹Ÿå³å…³é—­è¿æ¥ã€‚æ‰€ä»¥ä½ åœ¨CLOSE_WAITçŠ¶æ€ä¸‹ï¼Œéœ€è¦å®Œæˆçš„äº‹æƒ…æ˜¯ç­‰å¾…ä½ å»å…³é—­è¿æ¥ã€‚ï¼ˆè¢«åŠ¨æ–¹ï¼‰LAST_ACK: è¿™ä¸ªçŠ¶æ€è¿˜æ˜¯æ¯”è¾ƒå®¹æ˜“å¥½ç†è§£çš„ï¼Œå®ƒæ˜¯è¢«åŠ¨å…³é—­ä¸€æ–¹åœ¨å‘é€FINæŠ¥æ–‡åï¼Œæœ€åç­‰å¾…å¯¹æ–¹çš„ACKæŠ¥æ–‡ã€‚å½“æ”¶åˆ°ACKæŠ¥æ–‡åï¼Œä¹Ÿå³å¯ä»¥è¿›å…¥åˆ°CLOSEDå¯ç”¨çŠ¶æ€äº†ã€‚ï¼ˆè¢«åŠ¨æ–¹ï¼‰TIME_WAIT: è¡¨ç¤ºæ”¶åˆ°äº†å¯¹æ–¹çš„FINæŠ¥æ–‡ï¼Œå¹¶å‘é€å‡ºäº†ACKæŠ¥æ–‡ï¼Œå°±ç­‰2MSLåå³å¯å›åˆ°CLOSEDå¯ç”¨çŠ¶æ€äº†ã€‚å¦‚æœFINWAIT1çŠ¶æ€ä¸‹ï¼Œæ”¶åˆ°äº†å¯¹æ–¹åŒæ—¶å¸¦FINæ ‡å¿—å’ŒACKæ ‡å¿—çš„æŠ¥æ–‡æ—¶ï¼Œå¯ä»¥ç›´æ¥è¿›å…¥åˆ°TIME_WAITçŠ¶æ€ï¼Œè€Œæ— é¡»ç»è¿‡FIN_WAIT_2çŠ¶æ€ã€‚ï¼ˆä¸»åŠ¨æ–¹ï¼‰CLOSED: è¡¨ç¤ºè¿æ¥ä¸­æ–­ã€‚ ä¸‰ã€UDPå››ã€TCPä¸UDPç®€å•å¯¹æ¯”1ã€TCPçš„æ¦‚å¿µ TCPåœ¨ä¼ è¾“æ•°æ®ä¹‹å‰å¿…é¡»å…ˆå»ºç«‹è¿æ¥ï¼Œæ•°æ®ä¼ è¾“ç»“æŸåè¦é‡Šæ”¾è¿æ¥ã€‚ æ¯ä¸€æ¡TCPè¿æ¥åªèƒ½æœ‰2ä¸ªç«¯ç‚¹ï¼Œæ•…TCPä¸æä¾›å¹¿æ’­æˆ–å¤šæ’­æœåŠ¡ã€‚ TCPæä¾›å¯é äº¤äº’ï¼Œé€šè¿‡TCPè¿æ¥ä¼ è¾“çš„æ•°æ®ï¼Œæ— å·®é”™ã€ä¸ä¸¢å¤±ã€ä¸é‡å¤ã€å¹¶ä¸”æŒ‰åºåˆ°è¾¾ã€‚ TCPæ˜¯é¢å‘å­—èŠ‚æµçš„ã€‚è™½ç„¶åº”ç”¨è¿›ç¨‹å’ŒTCPçš„äº¤äº’æ˜¯ä¸€æ¬¡ä¸€ä¸ªæ•°æ®å—(å¤§å°ä¸ç­‰ï¼‰ï¼Œä½†TCPæŠŠåº”ç”¨ç¨‹åºäº¤ä¸‹æ¥çš„æ•°æ®çœ‹æˆä»…ä»…æ˜¯ä¸€è¿ä¸²çš„æ— ç»“æ„çš„å­—èŠ‚æµã€‚TCPå¹¶ä¸çŸ¥é“æ‰€ä¼ è¾“çš„å­—èŠ‚æµçš„å«ä¹‰ã€‚ 2ã€UDPçš„æ¦‚å¿µ UDPï¼ˆUser Datagram Protocolï¼‰ç”¨æˆ·æ•°æ®æŠ¥åè®®UDPæ˜¯ä¸€ç§æ— è¿æ¥çš„ï¼Œå°½æœ€å¤§åŠªåŠ›äº¤ä»˜çš„ï¼ŒåŸºäºæŠ¥æ–‡çš„ç«¯åˆ°ç«¯çš„ä¼ è¾“å±‚é€šä¿¡åè®®ã€‚ UDPï¼Œåœ¨å‘é€æ•°æ®ä¹‹å‰ä¸éœ€è¦å»ºç«‹è¿æ¥ã€‚ UDPä¸ä¿è¯å¯é äº¤äº’ï¼Œä¸»æœºä¸éœ€è¦ä½ç½®å¤æ‚çš„è¿æ¥çŠ¶æ€ã€‚ UDPæ˜¯é¢å‘æŠ¥æ–‡çš„ã€‚UDPå¯¹åº”ç”¨å±‚äº¤ä¸‹æ¥çš„æŠ¥æ–‡ï¼Œæ—¢ä¸åˆå¹¶ï¼Œä¹Ÿä¸æ‹†åˆ†ï¼Œè€Œæ˜¯ä¿ç•™è¿™äº›æŠ¥æ–‡çš„çš„è¾¹ç•Œï¼Œå³åº”ç”¨å±‚äº¤ç»™UDPå¤šé•¿çš„æŠ¥æ–‡ï¼ŒUDPå°±ç…§æ ·å‘é€ï¼Œå³ä¸€æ¬¡å‘é€ä¸€ä¸ªæŠ¥æ–‡ã€‚åœ¨æ¥æ”¶ç«¯ï¼ŒUDPä¸€æ¬¡äº¤ä»˜ä¸€ä¸ªå®Œæ•´çš„æŠ¥æ–‡ã€‚ UDPæ²¡æœ‰æ‹¥å¡æ§åˆ¶ï¼Œç½‘ç»œå‡ºç°çš„æ‹¥å¡ä¸ä¼šä½¿æºä¸»æœºçš„å‘é€é€Ÿç‡é™ä½ã€‚ UDPæ”¯æŒä¸€å¯¹ä¸€ã€ä¸€å¯¹å¤šã€å¤šå¯¹ä¸€å’Œå¤šå¯¹å¤šçš„äº¤äº’é€šä¿¡ã€‚ UDPçš„é¦–éƒ¨å¼€é”€å°ï¼Œåªæœ‰8ä¸ªå­—èŠ‚ï¼Œæ¯”TCPçš„20ä¸ªå­—èŠ‚çš„é¦–éƒ¨è¦çŸ­ã€‚ 3ã€åŒºåˆ« TCPåè®®é¢å‘è¿æ¥ï¼ŒUDPåè®®é¢å‘éè¿æ¥ã€‚ TCPåè®®ä¼ è¾“é€Ÿåº¦æ…¢ï¼ŒUDPåè®®ä¼ è¾“é€Ÿåº¦å¿«ã€‚ TCPåè®®ä¿è¯æ•°æ®é¡ºåºï¼ŒUDPåè®®ä¸ä¿è¯ã€‚ TCPåè®®ä¿è¯æ•°æ®æ­£ç¡®æ€§ï¼ŒUDPåè®®å¯èƒ½ä¸¢åŒ…ã€‚ TCPåè®®å¯¹ç³»ç»Ÿèµ„æºè¦æ±‚å¤šï¼ŒUDPåè®®è¦æ±‚å°‘ã€‚ 4ã€ä½¿ç”¨æƒ…å†µ TCPåè®®é€‚ç”¨äºå¯¹æ•ˆç‡è¦æ±‚ç›¸å¯¹ä½ï¼Œä½†å¯¹å‡†ç¡®æ€§è¦æ±‚ç›¸å¯¹é«˜çš„åœºæ™¯ä¸‹ï¼Œæˆ–è€…æ˜¯æœ‰ä¸€ç§è¿æ¥æ¦‚å¿µçš„åœºæ™¯ä¸‹ã€‚ è€ŒUDPåè®®é€‚ç”¨äºå¯¹æ•ˆç‡è¦æ±‚ç›¸å¯¹é«˜ï¼Œå¯¹å‡†ç¡®æ€§è¦æ±‚ç›¸å¯¹ä½çš„åœºæ™¯ã€‚","link":"/2020/10/23/computer_network/tcp-udp/"},{"title":"Happy Birthday to you!!!","text":"","link":"/2020/10/20/my_life/happy-birthday/"},{"title":"HashMap æºç ç¿»è¯‘","text":"åŸºäºJDK1.8 ç‰ˆæƒå£°æ˜>folded12345678910111213141516171819/* * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * ç‰ˆæƒæ‰€æœ‰ï¼ˆcï¼‰1997ã€2013ï¼ŒOracle å’Œ/æˆ– å…¶åˆ†æ”¯æœºæ„ã€‚ ç‰ˆæƒæ‰€æœ‰ã€‚ * Oracle ä¸“æœ‰/æœºå¯†ã€‚ ä½¿ç”¨é¡»éµå®ˆè®¸å¯æ¡æ¬¾ã€‚ * */package java.util;import java.io.IOException;import java.io.InvalidObjectException;import java.io.Serializable;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.function.BiConsumer;import java.util.function.BiFunction;import java.util.function.Consumer;import java.util.function.Function; ç±»è¯´æ˜>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/** * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface. This * implementation provides all of the optional map operations, and permits * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key. (The &lt;tt&gt;HashMap&lt;/tt&gt; * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is * unsynchronized and permits nulls.) This class makes no guarantees as to * the order of the map; in particular, it does not guarantee that the order * will remain constant over time. * åŸºäºå“ˆå¸Œè¡¨çš„Mapæ¥å£çš„å®ç°ã€‚æ­¤å®ç°æä¾›æ‰€æœ‰å¯é€‰çš„mapæ“ä½œï¼Œå¹¶[å…è®¸nullå€¼å’Œnullé”®]ã€‚ * ï¼ˆHashMapç±»ä¸Hashtableå¤§è‡´ç­‰æ•ˆï¼Œä¸åŒä¹‹å¤„åœ¨äºå®ƒæ˜¯ä¸åŒæ­¥çš„ï¼Œå¹¶ä¸”å…è®¸ä¸ºnullã€‚ï¼‰ * æ­¤ç±»ä¸ä¿è¯mapå…ƒç´ çš„é¡ºåºã€‚ç‰¹åˆ«æ˜¯ï¼Œå®ƒä¸èƒ½ä¿è¯é¡ºåºä¼šéšç€æ—¶é—´çš„æ¨ç§»ä¿æŒæ’å®šã€‚ * * &lt;p&gt;This implementation provides constant-time performance for the basic * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function * disperses the elements properly among the buckets. Iteration over * collection views requires time proportional to the &quot;capacity&quot; of the * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number * of key-value mappings). Thus, it's very important not to set the initial * capacity too high (or the load factor too low) if iteration performance is * important. * å‡è®¾å“ˆå¸Œå‡½æ•°å°†å…ƒç´ æ­£ç¡®çš„åˆ†æ•£åœ¨å­˜å‚¨æ¡¶ä¸­ï¼Œåˆ™æ­¤å®ç°ä¸ºåŸºæœ¬æ“ä½œï¼ˆgetå’Œputï¼‰æä¾›æ’å®šæ—¶é—´çš„æ€§èƒ½ã€‚ * é›†åˆè§†å›¾è¿­ä»£æ‰€éœ€çš„æ—¶é—´ä¸HashMapå®ä¾‹çš„â€œå®¹é‡â€ï¼ˆå­˜å‚¨æ¡¶æ•°ï¼‰ä»¥åŠå…¶å¤§å°ï¼ˆé”®-å€¼æ˜ å°„æ•°ï¼‰æˆæ­£æ¯”ã€‚ * å› æ­¤ï¼Œå¦‚æœè¿­ä»£æ€§èƒ½å¾ˆé‡è¦ï¼Œåˆ™ä¸è¦å°†åˆå§‹å®¹é‡è®¾ç½®å¾—è¿‡é«˜ï¼ˆæˆ–è´Ÿè½½å› å­è¿‡ä½ï¼‰ï¼Œè¿™ä¸€ç‚¹éå¸¸é‡è¦ã€‚ * * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;. The * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial * capacity is simply the capacity at the time the hash table is created. The * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to * get before its capacity is automatically increased. When the number of * entries in the hash table exceeds the product of the load factor and the * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data * structures are rebuilt) so that the hash table has approximately twice the * number of buckets. * HashMapçš„å®ä¾‹å…·æœ‰ä¸¤ä¸ªå½±å“å…¶æ€§èƒ½çš„å‚æ•°ï¼šåˆå§‹å®¹é‡å’Œè´Ÿè½½å› å­ã€‚ * å®¹é‡æ˜¯å“ˆå¸Œè¡¨ä¸­èƒ½å­˜å‚¨çš„æ¡¶çš„æ•°é‡ï¼Œåˆå§‹å®¹é‡åªæ˜¯åˆ›å»ºå“ˆå¸Œè¡¨æ—¶çš„å®¹é‡ã€‚ * è´Ÿè½½å› å­æ˜¯å“ˆå¸Œè¡¨çš„å®¹é‡è‡ªåŠ¨å¢åŠ ä¹‹å‰å…è®¸å…¶å¡«å……çš„å¡«æ»¡ç¨‹åº¦çš„åº¦é‡ã€‚ * å½“å“ˆå¸Œè¡¨ä¸­çš„æ¡ç›®æ•°è¶…è¿‡è´Ÿè½½å› å­å’Œå½“å‰å®¹é‡çš„ä¹˜ç§¯æ—¶ï¼Œå“ˆå¸Œè¡¨å°†è¢«é‡æ–°å“ˆå¸Œï¼ˆå³ï¼Œå†…éƒ¨æ•°æ®ç»“æ„å°†è¢«é‡å»ºï¼‰ï¼Œå› æ­¤å“ˆå¸Œè¡¨çš„å®¹é‡å¤§çº¦ä¸ºæ¡¶æ•°çš„ä¸¤å€ã€‚ * * &lt;p&gt;As a general rule, the default load factor (.75) offers a good * tradeoff between time and space costs. Higher values decrease the * space overhead but increase the lookup cost (reflected in most of * the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including * &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;). The expected number of entries in * the map and its load factor should be taken into account when * setting its initial capacity, so as to minimize the number of * rehash operations. If the initial capacity is greater than the * maximum number of entries divided by the load factor, no rehash * operations will ever occur. * é€šå¸¸ï¼Œé»˜è®¤è´Ÿè½½å› å­ï¼ˆ0.75ï¼‰åœ¨æ—¶é—´å’Œç©ºé—´æˆæœ¬ä¹‹é—´æä¾›äº†å¾ˆå¥½çš„æŠ˜ä¸­ã€‚ * è¾ƒé«˜çš„å€¼ä¼šå‡å°‘ç©ºé—´å¼€é”€ï¼Œä½†ä¼šå¢åŠ æŸ¥æ‰¾æˆæœ¬ï¼ˆåœ¨HashMapç±»çš„å¤§å¤šæ•°æ“ä½œä¸­éƒ½å¾—åˆ°ä½“ç°ï¼ŒåŒ…æ‹¬getå’Œputï¼‰ã€‚ * è®¾ç½®å…¶åˆå§‹å®¹é‡æ—¶ï¼Œåº”è€ƒè™‘æ˜ å°„ä¸­çš„é¢„æœŸæ¡ç›®æ•°åŠå…¶è´Ÿè½½å› å­ï¼Œä»¥æœ€å¤§ç¨‹åº¦åœ°å‡å°‘é‡æ–°å“ˆå¸Œæ“ä½œçš„æ¬¡æ•°ã€‚ * å¦‚æœåˆå§‹å®¹é‡å¤§äºæœ€å¤§æ¡ç›®æ•°é™¤ä»¥è´Ÿè½½å› å­ï¼Œåˆ™å°†ä¸ä¼šè¿›è¡Œä»»ä½•å“ˆå¸Œæ“ä½œã€‚ * ï¼ˆå³ åˆå§‹å®¹é‡ * è´Ÿè½½å› å­ &gt; æœ€å¤§æ¡ç›®æ•°ï¼‰ï¼Œè¿™é‡Œæœ€å¤§æ¡ç›®æ•°æŒ‡é¢„æœŸè¦å­˜å‚¨çš„æœ€å¤§æ¡¶å­æ•° * * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt; * instance, creating it with a sufficiently large capacity will allow * the mappings to be stored more efficiently than letting it perform * automatic rehashing as needed to grow the table. Note that using * many keys with the same {@code hashCode()} is a sure way to slow * down performance of any hash table. To ameliorate impact, when keys * are {@link Comparable}, this class may use comparison order among * keys to help break ties. * å¦‚æœå°†è®¸å¤šæ˜ å°„å­˜å‚¨åœ¨HashMapå®ä¾‹ä¸­ï¼Œåˆ™åˆ›å»ºå…·æœ‰è¶³å¤Ÿå¤§å®¹é‡çš„æ˜ å°„å°†æ¯”è®©å…¶æ ¹æ®éœ€è¦é€šè¿‡è‡ªåŠ¨é‡æ–°å“ˆå¸Œå¤„ç†æ¥å¢é•¿è¡¨ä¼šæ›´æœ‰æ•ˆåœ°å­˜å‚¨æ˜ å°„ã€‚ * è¯·æ³¨æ„ï¼Œä½¿ç”¨è®¸å¤šå…·æœ‰ç›¸åŒhashCode()å€¼çš„é”®æ˜¯é™ä½ä»»ä½•å“ˆå¸Œè¡¨æ€§èƒ½çš„è‚¯å®šæ–¹æ³•ã€‚ * ä¸ºäº†æ”¹å–„å½±å“ï¼Œå½“é”®ä¸ºComparableç±»å‹æ—¶ï¼Œæ­¤ç±»å¯ä»¥ä½¿ç”¨é”®ä¹‹é—´çš„æ¯”è¾ƒé¡ºåºæ¥å¸®åŠ©æ‰“ç ´å…³ç³»ã€‚ * * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; * If multiple threads access a hash map concurrently, and at least one of * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be * synchronized externally. (A structural modification is any operation * that adds or deletes one or more mappings; merely changing the value * associated with a key that an instance already contains is not a * structural modification.) This is typically accomplished by * synchronizing on some object that naturally encapsulates the map. * è¯·æ³¨æ„ï¼Œæ­¤å®ç°æœªåŒæ­¥ã€‚ å¦‚æœå¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å“ˆå¸Œæ˜ å°„ï¼Œå¹¶ä¸”è‡³å°‘ä¸€ä¸ªçº¿ç¨‹åœ¨ç»“æ„ä¸Šä¿®æ”¹äº†è¯¥æ˜ å°„ï¼Œåˆ™å¿…é¡»åœ¨å¤–éƒ¨è¿›è¡ŒåŒæ­¥ã€‚ * ï¼ˆç»“æ„ä¿®æ”¹æ˜¯æ·»åŠ æˆ–åˆ é™¤ä¸€ä¸ªæˆ–å¤šä¸ªæ˜ å°„çš„ä»»ä½•æ“ä½œï¼›ä»…æ›´æ”¹ä¸å®ä¾‹å·²ç»åŒ…å«çš„é”®ç›¸å…³è”çš„å€¼ä¸æ˜¯ç»“æ„ä¿®æ”¹ã€‚ï¼‰ * é€šå¸¸å¯ä»¥é€šè¿‡åœ¨å°è£…äº†mapçš„æŸä¸ªå¯¹è±¡ä¸Šè¿›è¡ŒåŒæ­¥æ¥å®ç°ã€‚ * * If no such object exists, the map should be &quot;wrapped&quot; using the * {@link Collections#synchronizedMap Collections.synchronizedMap} * method. This is best done at creation time, to prevent accidental * unsynchronized access to the map:&lt;pre&gt; * Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt; * å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„å¯¹è±¡ï¼Œåˆ™åº”ä½¿ç”¨Collections.synchronizedMapæ–¹æ³•â€œåŒ…è£…â€mapã€‚ * æœ€å¥½åœ¨åˆ›å»ºæ—¶å®Œæˆæ­¤æ“ä½œï¼Œä»¥é˜²æ­¢æ„å¤–ä¸åŒæ­¥åœ°è®¿é—®mapï¼š * Map m = Collections.synchronizedMap(new HashMap(...)); * * &lt;p&gt;The iterators returned by all of this class's &quot;collection view methods&quot; * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after * the iterator is created, in any way except through the iterator's own * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a * {@link ConcurrentModificationException}. Thus, in the face of concurrent * modification, the iterator fails quickly and cleanly, rather than risking * arbitrary, non-deterministic behavior at an undetermined time in the * future. * æ­¤ç±»çš„æ‰€æœ‰â€œé›†åˆè§†å›¾æ–¹æ³•â€è¿”å›çš„è¿­ä»£å™¨éƒ½æ˜¯â€œfail-fastâ€ï¼ˆå¿«é€Ÿå¤±è´¥æœºåˆ¶ï¼‰çš„ï¼šå¦‚æœåœ¨åˆ›å»ºè¿­ä»£å™¨åçš„ä»»ä½•æ—¶é—´ä»¥ä»»ä½•æ–¹å¼å¯¹æ˜ å°„è¿›è¡Œç»“æ„ä¿®æ”¹ï¼Œ * åˆ™é™¤äº†é€šè¿‡è¿­ä»£å™¨è‡ªå·±çš„removeæ–¹æ³•ä¹‹å¤–ï¼Œè¿­ä»£å™¨éƒ½ä¼šæŠ›å‡ºConcurrentModificationExceptionã€‚ * å› æ­¤ï¼Œé¢å¯¹å¹¶å‘ä¿®æ”¹ï¼Œè¿­ä»£å™¨å°†å¿«é€Ÿè€Œå¹²å‡€åœ°å¤±è´¥ï¼Œè€Œä¸æ˜¯å†’ç€åœ¨æœªæ¥ä¸ç¡®å®šçš„æ—¶é—´å†’ä»»ä½•ä¸ç¡®å®šè¡Œä¸ºçš„é£é™©ã€‚ * * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed * as it is, generally speaking, impossible to make any hard guarantees in the * presence of unsynchronized concurrent modification. Fail-fast iterators * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis. * Therefore, it would be wrong to write a program that depended on this * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators * should be used only to detect bugs.&lt;/i&gt; * æ³¨æ„ï¼Œä¸èƒ½ä¿è¯è¿­ä»£å™¨çš„å¿«é€Ÿå¤±è´¥è¡Œä¸ºï¼Œå› ä¸ºé€šå¸¸æ¥è¯´ï¼Œåœ¨å­˜åœ¨ä¸åŒæ­¥çš„å¹¶å‘ä¿®æ”¹çš„æƒ…å†µä¸‹ï¼Œä¸å¯èƒ½åšå‡ºä»»ä½•ä¸¥æ ¼çš„ä¿è¯ã€‚ * å¿«é€Ÿå¤±è´¥çš„è¿­ä»£å™¨ä¼šå°½æœ€å¤§åŠªåŠ›æŠ›å‡ºConcurrentModificationExceptionã€‚å› æ­¤ï¼Œç¼–å†™ä¾èµ–äºæ­¤å¼‚å¸¸çš„ç¨‹åºçš„æ­£ç¡®æ€§æ˜¯é”™è¯¯çš„ï¼šè¿­ä»£å™¨çš„å¿«é€Ÿå¤±è´¥è¡Œä¸ºåº”ä»…ç”¨äºæ£€æµ‹é”™è¯¯ã€‚ * * &lt;p&gt;This class is a member of the * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt; * Java Collections Framework&lt;/a&gt;. * æ­¤ç±»æ˜¯Java Collections Frameworkçš„æˆå‘˜ã€‚ * * @param &lt;K&gt; the type of keys maintained by this map | è¿™æ˜¯mapç»´æŠ¤çš„é”®çš„ç±»å‹ * @param &lt;V&gt; the type of mapped values | è¿™æ˜¯æ˜ å°„çš„å€¼çš„ç±»å‹ * * @author Doug Lea * @author Josh Bloch * @author Arthur van Hoff * @author Neal Gafter * @see Object#hashCode() * @see Collection * @see Map * @see TreeMap * @see Hashtable * @since 1.2 */ ç±»ä¸»ä½“å®ç°è¯´æ˜>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable { private static final long serialVersionUID = 362498820763181265L; /* * Implementation notes. * * This map usually acts as a binned (bucketed) hash table, but * when bins get too large, they are transformed into bins of * TreeNodes, each structured similarly to those in * java.util.TreeMap. Most methods try to use normal bins, but * relay to TreeNode methods when applicable (simply by checking * instanceof a node). Bins of TreeNodes may be traversed and * used like any others, but additionally support faster lookup * when overpopulated. However, since the vast majority of bins in * normal use are not overpopulated, checking for existence of * tree bins may be delayed in the course of table methods. * è¯¥mapé€šå¸¸ç”¨ä½œè£…ç®±ï¼ˆå­˜å‚¨æ¡¶ï¼‰çš„å“ˆå¸Œè¡¨ï¼Œä½†æ˜¯å½“æ¡¶å­å¤ªå¤§æ—¶ï¼Œå®ƒä»¬å°†è½¬æ¢ä¸ºTreeNodesçš„æ ‘å½¢ç»“æ„çš„æ¡¶ï¼Œæ¯ä¸ªæ¡¶çš„ç»“æ„ä¸java.util.TreeMapä¸­çš„ç›¸ä¼¼ã€‚ * å¤§å¤šæ•°æ–¹æ³•å°è¯•ä½¿ç”¨æ™®é€šçš„ç®±ï¼Œä½†æ˜¯åœ¨é€‚ç”¨æ—¶è½¬æ¥åˆ°TreeNodeæ–¹æ³•ï¼ˆåªéœ€é€šè¿‡æ£€æŸ¥ instanceof nodeï¼‰ã€‚ * TreeNodesçš„æ ‘å½¢æ¡¶å¯ä»¥åƒå…¶ä»–ä»»ä½•éå†ä¸€æ ·ä½¿ç”¨ï¼Œè€Œä¸”è¿‡å¤šæ—¶è¿˜æ”¯æŒæ›´å¿«çš„æŸ¥æ‰¾ã€‚ * ä½†æ˜¯ï¼Œç”±äºæ­£å¸¸ä½¿ç”¨ä¸­çš„ç»å¤§å¤šæ•°æ—¶å€™å­˜å‚¨æ¡¶éƒ½æ²¡æœ‰Nodeè¿‡å¤šï¼Œå› æ­¤åœ¨ä½¿ç”¨è¡¨æ ¼æ–¹æ³•çš„è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½ä¼šå»¶è¿Ÿæ£€æŸ¥æ˜¯å¦å­˜åœ¨æ ‘å‹æ¡¶ã€‚ * * Tree bins (i.e., bins whose elements are all TreeNodes) are * ordered primarily by hashCode, but in the case of ties, if two * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;, * type then their compareTo method is used for ordering. (We * conservatively check generic types via reflection to validate * this -- see method comparableClassFor). The added complexity * of tree bins is worthwhile in providing worst-case O(log n) * operations when keys either have distinct hashes or are * orderable, Thus, performance degrades gracefully under * accidental or malicious usages in which hashCode() methods * return values that are poorly distributed, as well as those in * which many keys share a hashCode, so long as they are also * Comparable. (If neither of these apply, we may waste about a * factor of two in time and space compared to taking no * precautions. But the only known cases stem from poor user * programming practices that are already so slow that this makes * little difference.) * æ ‘ç®±ï¼ˆå³ï¼Œå…ƒç´ å‡ä¸ºTreeNodeçš„ç®±-æ ‘å½¢æ¡¶ï¼‰ä¸»è¦ç”±hashCodeæ’åºï¼Œä½†åœ¨æœ‰è”ç³»çš„æƒ…å†µä¸‹ï¼Œå¦‚æœä¸¤ä¸ªå…ƒç´ å±äºç›¸åŒçš„ &quot;class C implements Comparable&lt;C&gt;&quot; ç±»å‹ï¼Œ * åˆ™å¯ä»¥é€šè¿‡ä»–ä»¬çš„compareToæ–¹æ³•è¿›è¡Œæ’åºã€‚ï¼ˆæˆ‘ä»¬é€šè¿‡åå°„ä¿å®ˆåœ°æ£€æŸ¥æ³›å‹ç±»å‹ä»¥éªŒè¯è¿™ä¸€ç‚¹ -- çœ‹ comparableClassFor æ–¹æ³•ï¼‰ * å½“é”®å…·æœ‰ä¸åŒçš„å“ˆå¸Œå€¼æˆ–å¯æ’åºæ—¶ï¼Œåœ¨æœ€åçš„æƒ…å†µ O(log n) æ“ä½œä¸‹å¢åŠ æ ‘ç®±çš„å¤æ‚æ€§æ˜¯å€¼å¾—çš„ï¼Œå› æ­¤ï¼Œåœ¨æ„å¤–æˆ–æ¶æ„ä½¿ç”¨ä¸­ hashCode() æ–¹æ³•è¿”å›åˆ†å¸ƒä¸å‡çš„å€¼çš„æƒ…å†µä¸‹ï¼Œæ€§èƒ½ä¼šä¼˜é›…é™ä½ï¼Œ * è®¸å¤šé”®å…±äº«ä¸€ä¸ªhashCodeå€¼æ—¶ä¹Ÿæ˜¯ä¸€æ ·ï¼Œåªè¦å®ƒä»¬ä¹Ÿæ˜¯å¯æ¯”è¾ƒçš„ã€‚ï¼ˆå¦‚æœè¿™ä¸¤ç§æ–¹æ³•éƒ½ä¸é€‚ç”¨ï¼Œé‚£ä¹ˆä¸ä¸é‡‡å–é¢„é˜²æªæ–½ç›¸æ¯”ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šåœ¨æ—¶é—´å’Œç©ºé—´ä¸Šæµªè´¹å¤§çº¦ä¸¤å€çš„æ—¶é—´ã€‚ * ä½†æ˜¯ï¼Œå”¯ä¸€å·²çŸ¥çš„æƒ…å†µæ˜¯ç”±äºä¸è‰¯çš„ç”¨æˆ·ç¼–ç¨‹å®è·µå·²ç»å¦‚æ­¤ä¹‹æ…¢ï¼Œä»¥è‡³äºå‡ ä¹æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚ï¼‰ * * Because TreeNodes are about twice the size of regular nodes, we * use them only when bins contain enough nodes to warrant use * (see TREEIFY_THRESHOLD). And when they become too small (due to * removal or resizing) they are converted back to plain bins. In * usages with well-distributed user hashCodes, tree bins are * rarely used. Ideally, under random hashCodes, the frequency of * nodes in bins follows a Poisson distribution * (http://en.wikipedia.org/wiki/Poisson_distribution) with a * parameter of about 0.5 on average for the default resizing * threshold of 0.75, although with a large variance because of * resizing granularity. Ignoring variance, the expected * occurrences of list size k are (exp(-0.5) * pow(0.5, k) / * factorial(k)). The first values are: * * 0: 0.60653066 * 1: 0.30326533 * 2: 0.07581633 * 3: 0.01263606 * 4: 0.00157952 * 5: 0.00015795 * 6: 0.00001316 * 7: 0.00000094 * 8: 0.00000006 * more: less than 1 in ten million * ç”±äºTreeNodeçš„å¤§å°çº¦ä¸ºå¸¸è§„Nodeçš„ä¸¤å€ï¼Œå› æ­¤ä»…åœ¨å­˜å‚¨æ¡¶åŒ…å«è¶³å¤Ÿå¤šçš„Nodeæ—¶ï¼Œæˆ‘ä»¬æ‰ä½¿ç”¨å®ƒä»¬ï¼ˆTreeNodeï¼‰ï¼ˆè¯·å‚é˜…TREEIFY_THRESHOLDï¼‰ã€‚ * å½“å®ƒä»¬å˜å¾—å¤ªå°ï¼ˆç”±äºç§»é™¤æˆ–è°ƒæ•´å¤§å°ï¼‰æ—¶ï¼Œå®ƒä»¬ä¼šè½¬æ¢å›æ™®é€šç®±ï¼ˆæ™®é€šç®±æ”¾æ™®é€šNodeèŠ‚ç‚¹å…ƒç´ ï¼Œæ ‘ç®±æ”¾TreeNodeèŠ‚ç‚¹å…ƒç´ ï¼‰ã€‚ * åœ¨ç”¨æˆ·hashCodeå…·æœ‰è‰¯å¥½åˆ†å¸ƒçš„ç”¨æ³•ä¸­ï¼Œå¾ˆå°‘ä½¿ç”¨æ ‘ç®±ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œåœ¨éšæœºhashCodesä¸‹ï¼Œç®±ä¸­èŠ‚ç‚¹çš„é¢‘ç‡éµå¾ªPoissonåˆ†å¸ƒï¼ˆhttp://en.wikipedia.org/wiki/Poisson_distributionï¼‰ï¼Œ * å…¶é»˜è®¤è°ƒæ•´å¤§å°é˜ˆå€¼ä¸º0.75ï¼Œå¹³å‡å‚æ•°çº¦ä¸º0.5ï¼Œå°½ç®¡ ç”±äºè°ƒæ•´ç²’åº¦çš„å·®å¼‚å¾ˆå¤§ã€‚ å¿½ç•¥æ–¹å·®ï¼Œåˆ—è¡¨å¤§å°kçš„é¢„æœŸå‡ºç°æ¬¡æ•°æ˜¯ï¼ˆexpï¼ˆ-0.5ï¼‰* powï¼ˆ0.5ï¼Œkï¼‰/ factorialï¼ˆkï¼‰ï¼‰ã€‚ * The first values are: * * 0: 0.60653066 * 1: 0.30326533 * 2: 0.07581633 * 3: 0.01263606 * 4: 0.00157952 * 5: 0.00015795 * 6: 0.00001316 * 7: 0.00000094 * 8: 0.00000006 * moreï¼šå°äºä¸€åƒä¸‡åˆ†ä¹‹ä¸€ * * The root of a tree bin is normally its first node. However, * sometimes (currently only upon Iterator.remove), the root might * be elsewhere, but can be recovered following parent links * (method TreeNode.root()). * æ ‘çš„æ ¹é€šå¸¸æ˜¯å®ƒçš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ä½†æ˜¯ï¼Œæœ‰æ—¶ï¼ˆå½“å‰ä»…åœ¨Iterator.removeä¸Šï¼‰ï¼Œæ ¹ç›®å½•å¯èƒ½åœ¨å…¶ä»–ä½ç½®ï¼Œä½†æ˜¯å¯ä»¥åœ¨çˆ¶é“¾æ¥ä¹‹åæ¢å¤ï¼ˆæ–¹æ³•TreeNode.root()ï¼‰ã€‚ * * All applicable internal methods accept a hash code as an * argument (as normally supplied from a public method), allowing * them to call each other without recomputing user hashCodes. * Most internal methods also accept a &quot;tab&quot; argument, that is * normally the current table, but may be a new or old one when * resizing or converting. * æ‰€æœ‰é€‚ç”¨çš„å†…éƒ¨æ–¹æ³•å‡æ¥æ”¶å“ˆå¸Œç ä½œä¸ºå‚æ•°ï¼ˆé€šå¸¸ç”±å…¬å…±æ–¹æ³•æä¾›ï¼‰ï¼Œä»è€Œå…è®¸å®ƒä»¬åœ¨ä¸é‡æ–°è®¡ç®—ç”¨æˆ·hashCodeçš„æƒ…å†µä¸‹å½¼æ­¤è°ƒç”¨ã€‚ * å¤§å¤šæ•°å†…éƒ¨æ–¹æ³•è¿˜æ¥å—â€œtabâ€å‚æ•°ï¼Œè¯¥å‚æ•°é€šå¸¸æ˜¯å½“å‰è¡¨ï¼Œä½†åœ¨è°ƒæ•´å¤§å°æˆ–è½¬æ¢æ—¶å¯ä»¥æ˜¯æ–°çš„æˆ–æ—§çš„ã€‚ * * When bin lists are treeified, split, or untreeified, we keep * them in the same relative access/traversal order (i.e., field * Node.next) to better preserve locality, and to slightly * simplify handling of splits and traversals that invoke * iterator.remove. When using comparators on insertion, to keep a * total ordering (or as close as is required here) across * rebalancings, we compare classes and identityHashCodes as * tie-breakers. * å½“æ¡¶è¢«æ ‘åŒ–ï¼Œæ‹†åˆ†æˆ–å»æ ‘åŒ–æ—¶ï¼Œåœ¨è®¿é—®/éå†çš„é¡ºåºï¼ˆå³å­—æ®µNode.nextï¼‰ä¸­æˆ‘ä»¬å°†å®ƒä»¬ä¿æŒç›¸åŒçš„å…³ç³»ï¼Œä»¥æ›´å¥½åœ°ä¿ç•™å±€éƒ¨æ€§ï¼Œå¹¶ç•¥å¾®ç®€åŒ–å¯¹è°ƒç”¨iterator.removeçš„æ‹†åˆ†å’Œéå†çš„å¤„ç†ã€‚ * åœ¨ä½¿ç”¨æ¯”è¾ƒå™¨æ’å…¥æ—¶ï¼Œä¸ºäº†ä¿æŒé‡æ–°å¹³è¡¡çš„æ€»ä½“é¡ºåºï¼ˆæˆ–æ­¤å¤„è¦æ±‚çš„æ¥è¿‘åº¦ï¼‰ï¼Œæˆ‘ä»¬å°†classeså’ŒidentityHashCodesè¿›è¡Œæ¯”è¾ƒä½œä¸ºé¡ºåºåˆ¤å®š * * The use and transitions among plain vs tree modes is * complicated by the existence of subclass LinkedHashMap. See * below for hook methods defined to be invoked upon insertion, * removal and access that allow LinkedHashMap internals to * otherwise remain independent of these mechanics. (This also * requires that a map instance be passed to some utility methods * that may create new nodes.) * å­ç±»LinkedHashMapçš„å­˜åœ¨ä½¿æ™®é€šæ¨¡å¼ä¸æ ‘æ¨¡å¼ä¹‹é—´çš„ä½¿ç”¨å’Œè½¬æ¢å˜å¾—å¤æ‚ã€‚ * è¯·å‚è§ä¸‹é¢çš„é’©å­æ–¹æ³•ï¼Œè¿™äº›é’©å­æ–¹æ³•å®šä¹‰ä¸ºåœ¨æ’å…¥ï¼Œåˆ é™¤å’Œè®¿é—®æ—¶è¢«è°ƒç”¨ï¼Œè¿™äº›æ–¹æ³•å…è®¸LinkedHashMapå†…éƒ¨ä¿æŒç‹¬ç«‹äºè¿™äº›æœºåˆ¶ã€‚ * ï¼ˆè¿™è¿˜è¦æ±‚å°†mapå®ä¾‹ä¼ é€’ç»™ä¸€äº›å¯èƒ½åˆ›å»ºæ–°èŠ‚ç‚¹çš„å·¥å…·å‹æ–¹æ³•ã€‚ï¼‰ * * The concurrent-programming-like SSA-based coding style helps * avoid aliasing errors amid all of the twisty pointer operations. * å¹¶å‘ç¼–ç¨‹ä¾‹å¦‚åŸºäºSSAçš„ç¼–ç é£æ ¼æœ‰åŠ©äºé¿å…æ‰€æœ‰åç§»æŒ‡é’ˆæ“ä½œä¸­çš„æ··å é”™è¯¯ã€‚ * */ é™æ€å˜é‡>folded DEFAULT_INITIAL_CAPACITY é»˜è®¤åˆå§‹å®¹é‡123456/** * The default initial capacity - MUST be a power of two. * é»˜è®¤åˆå§‹å®¹é‡ - å¿…é¡»ä¸º2çš„å¹‚ã€‚ * 1å·¦ç§»4ä½ = 2çš„4æ¬¡å¹‚ = 16 */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 >folded MAXIMUM_CAPACITY æœ€å¤§å®¹é‡12345678/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. * æœ€å¤§å®¹é‡ï¼Œå¦‚æœä»»ä¸€æ„é€ å‡½æ•°ä½¿ç”¨å‚æ•°éšå¼çš„æŒ‡å®šäº†æ›´é«˜çš„å€¼ï¼Œåˆ™ä½¿ç”¨è¯¥å®¹é‡ã€‚ * å®¹é‡å¿…é¡»ä¸º2çš„å¹‚ä¸” &lt;= 1 &lt;&lt; 30ã€‚ */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; >folded DEFAULT_LOAD_FACTOR é»˜è®¤è´Ÿè½½å› å­12345/** * The load factor used when none specified in constructor. * åœ¨æ„é€ å‡½æ•°ä¸­æœªæŒ‡å®šæ—¶ä½¿ç”¨çš„è´Ÿè½½ç³»æ•°ã€‚é»˜è®¤0.75 */static final float DEFAULT_LOAD_FACTOR = 0.75f; >folded TREEIFY_THRESHOLD æ ‘åŒ–é˜ˆå€¼1234567891011/** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. * é€‰æ‹©ä½¿ç”¨æ ‘ç»“æ„è€Œä¸æ˜¯åˆ—è¡¨ç»“æ„çš„è®¡æ•°é˜ˆå€¼ã€‚æ¡¶é‡Œå…ƒç´ æ·»åŠ åˆ°è‡³å°‘å…·æœ‰è¿™ä¹ˆå¤šæ—¶ï¼Œæ¡¶çš„ç»“æ„ä¼šè½¬æ¢ä¸ºæ ‘ç»“æ„ã€‚ * è¯¥å€¼å¿…é¡»å¤§äº2ï¼Œå¹¶ä¸”è‡³å°‘æ˜¯8æ‰èƒ½ä¸æ ‘åˆ é™¤ä¸­çš„å‡è®¾ï¼ˆå³æ”¶ç¼©æ—¶è½¬æ¢å›åŸå§‹åˆ—è¡¨ç»“æ„çš„æ¡¶ï¼‰ç›¸å•®åˆ */static final int TREEIFY_THRESHOLD = 8; >folded UNTREEIFY_THRESHOLD å»æ ‘åŒ–é˜ˆå€¼1234567/** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. * åœ¨resizeæ“ä½œæœŸé—´ç”¨äºå»æ ‘åŒ–ï¼ˆæ‹†åˆ†ï¼‰ç®±çš„è®¡æ•°é˜ˆå€¼ã€‚åº”å°äºTREEIFY_THRESHOLDï¼ˆæ ‘åŒ–é˜ˆå€¼ï¼‰ï¼Œå¹¶ä¸”æœ€å¤§ä¸º6ä»¥ä¸åˆ é™¤æ—¶çš„æ”¶ç¼©æ£€æµ‹ç›¸å•®åˆã€‚ */static final int UNTREEIFY_THRESHOLD = 6; >folded MIN_TREEIFY_CAPACITY æ ‘ç»“æ„å­˜åœ¨æ—¶æœ€å°tableè¡¨å®¹é‡123456789/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. * æ ‘ç»“æ„å­˜åœ¨çš„æœ€å°è¡¨å®¹é‡ã€‚ï¼ˆå¦åˆ™ï¼Œå¦‚æœæ¡¶ä¸­çš„èŠ‚ç‚¹è¿‡å¤šï¼Œåˆ™å°†è°ƒæ•´è¡¨çš„å¤§å° - å¢åŠ tableæ•°ç»„é•¿åº¦ã€‚ï¼‰ * åº”è‡³å°‘ä¸º 4 * TREEIFY_THRESHOLDï¼Œä»¥é¿å…è°ƒæ•´å¤§å°å’Œæ ‘åŒ–é˜ˆå€¼ä¹‹é—´å‘ç”Ÿå†²çªã€‚ */static final int MIN_TREEIFY_CAPACITY = 64; é™æ€å†…éƒ¨ç±»>folded Node æ™®é€šèŠ‚ç‚¹123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) * åŸºæœ¬å“ˆå¸Œç®±èŠ‚ç‚¹ï¼Œç”¨äºå¤§å¤šæ•°æ¡ç›®ã€‚ï¼ˆæœ‰å…³TreeNodeå­ç±»çš„ä¿¡æ¯ï¼Œè¯·å‚è§ä¸‹æ–‡ï¼›æœ‰å…³Entryå­ç±»çš„ä¿¡æ¯ï¼Œè¯·å‚è§LinkedHashMapã€‚ï¼‰ * èŠ‚ç‚¹å¯¹è±¡åŒ…å«å››ä¸ªå±æ€§ï¼škeyå€¼çš„hashå€¼ã€keyå€¼ã€æ˜ å°„çš„å€¼valueã€ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å¯¹è±¡ */static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + &quot;=&quot; + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; }} é™æ€å·¥å…·æ–¹æ³•>folded hash è®¡ç®—hashå€¼1234567891011121314151617181920212223242526272829303132333435363738394041424344/* ---------------- Static utilities -------------- *//** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don't benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. * è®¡ç®—key.hashCode()å¹¶å°†å“ˆå¸Œçš„è¾ƒé«˜ä½ç‰¹å¾ï¼ˆXORï¼‰æ‰©å±•åˆ°è¾ƒä½ä½ä¸­ã€‚ * ç”±äºè¯¥è¡¨ä½¿ç”¨2çš„å¹‚æ¬¡æ©ç ï¼Œå› æ­¤ä»…åœ¨å½“å‰æ©ç ä¸Šæ–¹çš„ä½ä¸­å‘ç”Ÿå˜åŒ–çš„å“ˆå¸Œé›†å°†å§‹ç»ˆå‘ç”Ÿå†²çªã€‚ * ï¼ˆä¼—æ‰€å‘¨çŸ¥çš„ä¾‹å­æ˜¯åœ¨å°è¡¨ä¸­åŒ…å«è¿ç»­æ•´æ•°çš„Floaté”®é›†ã€‚ï¼‰å› æ­¤ï¼Œæˆ‘ä»¬åº”ç”¨äº†ä¸€ç§å˜æ¢ï¼Œå°†å‘ä¸‹æ‰©å±•è¾ƒé«˜ä½çš„å½±å“ã€‚ * åœ¨é€Ÿåº¦ï¼Œå®ç”¨æ€§å’Œä½æ‰©å±•è´¨é‡ä¹‹é—´éœ€è¦æƒè¡¡ã€‚ç”±äºè®¸å¤šå¸¸è§çš„å“ˆå¸Œé›†å·²ç»åˆç†åˆ†å¸ƒï¼ˆå› æ­¤æ— æ³•ä»æ‰©å±•ä¸­å—ç›Šï¼‰ï¼Œå¹¶ä¸”ç”±äºæˆ‘ä»¬ä½¿ç”¨æ ‘æ¥å¤„ç†å®¹å™¨ä¸­çš„å¤§é‡å†²çªï¼Œ * å› æ­¤æˆ‘ä»¬ä»…ä»¥æœ€ä¾¿å®œçš„æ–¹å¼å¯¹ä¸€äº›ç§»ä½åçš„ä½è¿›è¡ŒXORï¼ˆå¼‚æˆ–è¿ç®—ï¼‰ï¼Œä»¥å‡å°‘ç³»ç»ŸæŸå¤±ï¼Œä»¥åŠåˆå¹¶è¾ƒé«˜ä½çš„å½±å“ï¼Œå¦åˆ™ç”±äºè¡¨èŒƒå›´çš„é™åˆ¶ï¼Œè¿™äº›ä½å°†æ°¸è¿œä¸ä¼šåœ¨ç´¢å¼•è®¡ç®—ä¸­ä½¿ç”¨ã€‚ * * æ„æ€å°±æ˜¯å°†é«˜ä½çš„äºŒè¿›åˆ¶ç‰¹å¾åˆå¹¶åˆ°ä½ä½ç‰¹å¾ä¸­ï¼ˆè¿™ä¹ˆåšçš„åŸå› æ˜¯åé¢å®šä½æ•°ç»„ä¸‹æ ‡ä½¿ç”¨çš„æ–¹æ³•æ˜¯ï¼š * hash &amp; (tab.length-1)ï¼Œè¿™ä¸ªäºŒè¿›åˆ¶è¿ç®—ä½¿å¾—hashé«˜ä½è¢«å±è”½æ²¡æœ‰èµ·ä½œç”¨ï¼Œæ‰€ä»¥ä¸ºäº†ä¿ç•™é«˜ä½çš„ç‰¹å¾å’Œå½±å“è€Œè¿›è¡Œäº†æ‰©å±•æ“ä½œï¼Œ * ä¿ç•™é«˜ä½ç‰¹å¾å¯ä»¥å‡å°hashç¢°æ’ï¼‰ã€‚ * ç¤ºä¾‹1ï¼šé«˜ä½ä½å¼‚æˆ–è¿ç®— * h=key.hashcode() 1111 1101 1101 1111 0101 1101 0010 1001 * ^ * h &gt;&gt;&gt; 16 0000 0000 0000 0000 1111 1101 1101 1111 * â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” * h ^ (h &gt;&gt;&gt; 16) 1111 1101 1101 1111 1010 0000 1111 0110 * * ç¤ºä¾‹2ï¼šå®šä½å…ƒç´ æ‰€å¤„çš„æ•°ç»„ä½ç½®ï¼ˆå‡è®¾æ­¤æ—¶æ•°ç»„é•¿åº¦=16ï¼‰ * hash 1111 1101 1101 1111 1010 0000 1111 0110 * &amp; * 16-1 0000 0000 0000 0000 0000 0000 0000 1111 * â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” * hash &amp; (16-1) 0000 0000 0000 0000 0000 0000 0000 0110 */static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} >folded comparableClassFor123456789101112131415161718192021222324/** * Returns x's Class if it is of the form &quot;class C implements * Comparable&lt;C&gt;&quot;, else null. * è¿”å› x çš„ class å¦‚æœ x instanceof Comparable * å¦åˆ™è¿”å› null */static Class&lt;?&gt; comparableClassFor(Object x) { if (x instanceof Comparable) { Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) { for (int i = 0; i &lt; ts.length; ++i) { if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; } } } return null;} >folded compareComparables123456789/** * Returns k.compareTo(x) if x matches kc (k's screened comparable * class), else 0. */@SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) // for cast to Comparablestatic int compareComparables(Class&lt;?&gt; kc, Object k, Object x) { return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x));} >folded tableSizeFor ç”Ÿæˆæ•°ç»„é•¿åº¦å€¼12345678910111213/** * Returns a power of two size for the given target capacity. * å¯¹äºç»™å®šçš„ç›®æ ‡å®¹é‡ï¼Œè¿”å›ä¸€ä¸ª2çš„æ¬¡å¹‚çš„å€¼ */static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;} æˆå‘˜å±æ€§>folded table æ•°ç»„123456789101112/* ---------------- Fields -------------- *//** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) * è¯¥tableåœ¨é¦–æ¬¡ä½¿ç”¨æ—¶åˆå§‹åŒ–ï¼Œå¹¶æ ¹æ®éœ€è¦è°ƒæ•´å¤§å°ã€‚ * åˆ†é…æ—¶ï¼Œé•¿åº¦å§‹ç»ˆæ˜¯2çš„å¹‚ã€‚ï¼ˆåœ¨æŸäº›æ“ä½œä¸­ï¼Œæˆ‘ä»¬è¿˜å…è®¸é•¿åº¦ä¸ºé›¶ï¼Œä»¥å…è®¸ä½¿ç”¨å½“å‰ä¸éœ€è¦çš„å¼•å¯¼æœºåˆ¶ã€‚ï¼‰ * transientä¿®é¥°ï¼Œè¯¥å±æ€§å€¼ä¸ä¼šè¢«åºåˆ—åŒ– */transient Node&lt;K,V&gt;[] table; >folded entrySet123456/** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). * ä¿å­˜ç¼“å­˜çš„entrySet() æ³¨æ„ï¼ŒAbstractMapå­—æ®µç”¨äºkeySet()å’Œvalues()ã€‚ */transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; >folded size12345/** * The number of key-value mappings contained in this map. * æ­¤mapä¸­åŒ…å«çš„é”®-å€¼æ˜ å°„æ•°ã€‚ */transient int size; >folded modCount HashMapç»“æ„ä¿®æ”¹æ¬¡æ•°12345678910/** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the HashMap fail-fast. (See ConcurrentModificationException). * å¯¹è¯¥HashMapè¿›è¡Œç»“æ„ä¿®æ”¹çš„æ¬¡æ•°ï¼Œç»“æ„ä¿®æ”¹æ˜¯æŒ‡æ›´æ”¹HashMapä¸­æ˜ å°„æ¬¡æ•°æˆ–ä»¥å…¶ä»–æ–¹å¼ä¿®æ”¹å…¶å†…éƒ¨ç»“æ„ï¼ˆä¾‹å¦‚ï¼Œé‡æ–°å“ˆå¸Œï¼‰çš„ä¿®æ”¹ã€‚ * æ­¤å­—æ®µç”¨äºä½¿HashMapçš„Collection-viewä¸Šçš„è¿­ä»£å™¨å¿«é€Ÿå¤±è´¥ã€‚ ï¼ˆè¯·å‚è§ConcurrentModificationExceptionï¼‰ã€‚ */transient int modCount; >folded threshold12345678910/** * The next size value at which to resize (capacity * load factor). * resizeæ—¶ä¸‹ä¸€ä¸ªå¤§å°çš„å€¼ï¼ˆå®¹é‡ * è´Ÿè½½å› å­ï¼‰ * @serial */// (The javadoc description is true upon serialization.// Additionally, if the table array has not been allocated, this// field holds the initial array capacity, or zero signifying// DEFAULT_INITIAL_CAPACITY.)int threshold; >folded loadFactor è´Ÿè½½å› å­123456/** * The load factor for the hash table. * å“ˆå¸Œè¡¨çš„è´Ÿè½½å› å­ * @serial */final float loadFactor; æˆå‘˜æ–¹æ³•>folded HashMap æ„é€ æ–¹æ³•1ï¼ˆåˆå§‹å®¹é‡ï¼Œè´Ÿè½½å› å­ï¼‰1234567891011121314151617181920212223/* ---------------- Public operations -------------- *//** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);} >folded HashMap æ„é€ æ–¹æ³•2ï¼ˆåˆå§‹å®¹é‡ï¼‰12345678910/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR);} >folded HashMap æ„é€ æ–¹æ³•312345678/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). * é»˜è®¤çš„åˆå§‹å®¹é‡ï¼ˆ16ï¼‰å’Œé»˜è®¤çš„è´Ÿè½½å› å­ï¼ˆ0.75ï¼‰ */public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted} >folded HashMap æ„é€ æ–¹æ³•4ï¼ˆMapç±»å‹å¯¹è±¡ï¼‰12345678910111213/** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);} >folded putMapEntries å°†ä¼ å…¥çš„mapçš„å…ƒç´ å…¨éƒ¨putè¿›å»123456789101112131415161718192021222324252627/** * Implements Map.putAll and Map constructor * å®ç°äº† Map.putAll å’Œ Mapçš„æ„é€ å™¨ * * @param m the map * @param evict false when initially constructing this map, else * true (relayed to method afterNodeInsertion). */final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) { int s = m.size(); if (s &gt; 0) { if (table == null) { // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); } else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); } }} >folded size è¿”å›é”®-å€¼æ˜ å°„æ•°é‡12345678/** * Returns the number of key-value mappings in this map. * * @return the number of key-value mappings in this map */public int size() { return size;} >folded isEmpty è¿”å›æ˜ å°„æ•°æ˜¯å¦ä¸º012345678/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings. * * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings */public boolean isEmpty() { return size == 0;} >folded get æ ¹æ®keyè·å–value123456789101112131415161718192021/** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code (key==null ? k==null : * key.equals(k))}, then this method returns {@code v}; otherwise * it returns {@code null}. (There can be at most one such mapping.) * * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it's also * possible that the map explicitly maps the key to {@code null}. * The {@link #containsKey containsKey} operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;} >folded getNode æ ¹æ®hashå€¼å’Œkeyè·å–NodeèŠ‚ç‚¹ï¼ˆNode/TreeNodeï¼‰1234567891011121314151617181920212223242526/** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null;} >folded containsKey è¿”å›mapæ˜¯å¦åŒ…å«æ­¤é”®1234567891011/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the * specified key. * * @param key The key whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified * key. */public boolean containsKey(Object key) { return getNode(hash(key), key) != null;} >folded put æ”¾å…ƒç´ ï¼ˆkeyï¼Œvalueï¼‰12345678910111213141516/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * å°†æŒ‡å®šå€¼ä¸è¯¥æ˜ å°„ä¸­çš„æŒ‡å®šé”®ç›¸å…³è”ã€‚å¦‚æœè¯¥æ˜ å°„å…ˆå‰åŒ…å«è¯¥é”®çš„æ˜ å°„ï¼Œåˆ™æ›¿æ¢æ—§å€¼ * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */public V put(K key, V value) { return putVal(hash(key), key, value, false, true);} >folded putVal å…·ä½“putæ–¹æ³•çš„å®ç°12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;} >folded resize é‡å»ºtableè¡¨ã€‚åˆå§‹åŒ–æˆ–2å€æ‰©å®¹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab;} >folded treeifyBin æ ‘åŒ–ç»™å®šhashå€¼å¯¹åº”çš„æ¡¶æ‰€æœ‰å…ƒç´ 1234567891011121314151617181920212223242526/** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. * æ ‘åŒ–ç»™å®šhashå€¼å¯¹åº”çš„æ¡¶æ‰€æœ‰å…ƒç´ ï¼Œé™¤étableè¡¨å¤ªå° - tab.length &lt; MIN_TREEIFY_CAPACITYã€‚ * tableè¡¨å¤ªå°çš„æƒ…å†µå°±è¿›è¡Œä¸€éresizeè¡¨é‡å»ºã€‚ */final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) { int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) { TreeNode&lt;K,V&gt; hd = null, tl = null; do { TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); }} >folded putAll å°†ä¼ å…¥çš„mapçš„å…ƒç´ å…¨éƒ¨putè¿›å»1234567891011/** * Copies all of the mappings from the specified map to this map. * These mappings will replace any mappings that this map had for * any of the keys currently in the specified map. * * @param m mappings to be stored in this map * @throws NullPointerException if the specified map is null */public void putAll(Map&lt;? extends K, ? extends V&gt; m) { putMapEntries(m, true);} >folded remove åˆ é™¤æŒ‡å®šé”®çš„æ˜ å°„1234567891011121314/** * Removes the mapping for the specified key from this map if present. * å¦‚æœå­˜åœ¨ï¼Œåˆ™ä»æ­¤mapä¸­åˆ é™¤æŒ‡å®šé”®çš„æ˜ å°„ã€‚ * @param key key whose mapping is to be removed from the map * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */public V remove(Object key) { Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;} >folded removeNode åˆ é™¤æŒ‡å®šé”®çš„èŠ‚ç‚¹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Implements Map.remove and related methods * * @param hash hash for key * @param key the key * @param value the value to match if matchValue, else ignored * @param matchValue if true only remove if value is equal * @param movable if false do not move other nodes while removing * @return the node, or null if none */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) { Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null;} >folded clear åˆ é™¤å…¨éƒ¨é”®å€¼æ˜ å°„12345678910111213/** * Removes all of the mappings from this map. * The map will be empty after this call returns. */public void clear() { Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) { size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; }} >folded containsValue åˆ¤æ–­æ˜¯å¦åŒ…å«æ­¤å€¼123456789101112131415161718192021/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value. * * @param value value whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value */public boolean containsValue(Object value) { Node&lt;K,V&gt;[] tab; V v; if ((tab = table) != null &amp;&amp; size &gt; 0) { for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) { if ((v = e.value) == value || (value != null &amp;&amp; value.equals(v))) return true; } } } return false;} >folded keySet è¿”å›mapåŒ…å«çš„æ‰€æœ‰keyå€¼seté›†åˆ12345678910111213141516171819/** * Returns a {@link Set} view of the keys contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. If the map is modified * while an iteration over the set is in progress (except through * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of * the iteration are undefined. The set supports element removal, * which removes the corresponding mapping from the map, via the * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;, * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; * operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; * operations. * * @return a set view of the keys contained in this map */public Set&lt;K&gt; keySet() { Set&lt;K&gt; ks; return (ks = keySet) == null ? (keySet = new KeySet()) : ks;} KeySetå†…éƒ¨ç±»>folded1234567891011121314151617181920212223242526final class KeySet extends AbstractSet&lt;K&gt; { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator&lt;K&gt; iterator() { return new KeyIterator(); } public final boolean contains(Object o) { return containsKey(o); } public final boolean remove(Object key) { return removeNode(hash(key), key, null, false, true) != null; } public final Spliterator&lt;K&gt; spliterator() { return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer&lt;? super K&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); } if (modCount != mc) throw new ConcurrentModificationException(); } }} >folded values è¿”å›mapä¸­æ‰€æœ‰valueçš„é›†åˆ12345678910111213141516171819/** * Returns a {@link Collection} view of the values contained in this map. * The collection is backed by the map, so changes to the map are * reflected in the collection, and vice-versa. If the map is * modified while an iteration over the collection is in progress * (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), * the results of the iteration are undefined. The collection * supports element removal, which removes the corresponding * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations. It does not * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * @return a view of the values contained in this map */public Collection&lt;V&gt; values() { Collection&lt;V&gt; vs; return (vs = values) == null ? (values = new Values()) : vs;} Valueså†…éƒ¨ç±»>folded1234567891011121314151617181920212223final class Values extends AbstractCollection&lt;V&gt; { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator&lt;V&gt; iterator() { return new ValueIterator(); } public final boolean contains(Object o) { return containsValue(o); } public final Spliterator&lt;V&gt; spliterator() { return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer&lt;? super V&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.value); } if (modCount != mc) throw new ConcurrentModificationException(); } }} >folded entrySet è¿”å›mapåŒ…å«çš„é”®å€¼æ˜ å°„é›†åˆ1234567891011121314151617181920/** * Returns a {@link Set} view of the mappings contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. If the map is modified * while an iteration over the set is in progress (except through * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the * iterator) the results of the iteration are undefined. The set * supports element removal, which removes the corresponding * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and * &lt;tt&gt;clear&lt;/tt&gt; operations. It does not support the * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * @return a set view of the mappings contained in this map */public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;} EntrySetå†…éƒ¨ç±»>folded1234567891011121314151617181920212223242526272829303132333435363738394041final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return new EntryIterator(); } public final boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); } public final boolean remove(Object o) { if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; } return false; } public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() { return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e); } if (modCount != mc) throw new ConcurrentModificationException(); } }} é‡å†™JDK8 Mapæ‰©å±•æ–¹æ³•>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260// Overrides of JDK8 Map extension methods@Overridepublic V getOrDefault(Object key, V defaultValue) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;}@Overridepublic V putIfAbsent(K key, V value) { return putVal(hash(key), key, value, true, true);}@Overridepublic boolean remove(Object key, Object value) { return removeNode(hash(key), key, value, true, true) != null;}@Overridepublic boolean replace(K key, V oldValue, V newValue) { Node&lt;K,V&gt; e; V v; if ((e = getNode(hash(key), key)) != null &amp;&amp; ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) { e.value = newValue; afterNodeAccess(e); return true; } return false;}@Overridepublic V replace(K key, V value) { Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) != null) { V oldValue = e.value; e.value = value; afterNodeAccess(e); return oldValue; } return null;}@Overridepublic V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) { if (mappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) { if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else { Node&lt;K,V&gt; e = first; K k; do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { old = e; break; } ++binCount; } while ((e = e.next) != null); } V oldValue; if (old != null &amp;&amp; (oldValue = old.value) != null) { afterNodeAccess(old); return oldValue; } } V v = mappingFunction.apply(key); if (v == null) { return null; } else if (old != null) { old.value = v; afterNodeAccess(old); return v; } else if (t != null) t.putTreeVal(this, tab, hash, key, v); else { tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); } ++modCount; ++size; afterNodeInsertion(true); return v;}public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) { if (remappingFunction == null) throw new NullPointerException(); Node&lt;K,V&gt; e; V oldValue; int hash = hash(key); if ((e = getNode(hash, key)) != null &amp;&amp; (oldValue = e.value) != null) { V v = remappingFunction.apply(key, oldValue); if (v != null) { e.value = v; afterNodeAccess(e); return v; } else removeNode(hash, key, null, false, true); } return null;}@Overridepublic V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) { if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) { if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else { Node&lt;K,V&gt; e = first; K k; do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { old = e; break; } ++binCount; } while ((e = e.next) != null); } } V oldValue = (old == null) ? null : old.value; V v = remappingFunction.apply(key, oldValue); if (old != null) { if (v != null) { old.value = v; afterNodeAccess(old); } else removeNode(hash, key, null, false, true); } else if (v != null) { if (t != null) t.putTreeVal(this, tab, hash, key, v); else { tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); } ++modCount; ++size; afterNodeInsertion(true); } return v;}@Overridepublic V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) { if (value == null) throw new NullPointerException(); if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) { if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else { Node&lt;K,V&gt; e = first; K k; do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { old = e; break; } ++binCount; } while ((e = e.next) != null); } } if (old != null) { V v; if (old.value != null) v = remappingFunction.apply(old.value, value); else v = value; if (v != null) { old.value = v; afterNodeAccess(old); } else removeNode(hash, key, null, false, true); return v; } if (value != null) { if (t != null) t.putTreeVal(this, tab, hash, key, value); else { tab[i] = newNode(hash, key, value, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); } ++modCount; ++size; afterNodeInsertion(true); } return value;}@Overridepublic void forEach(BiConsumer&lt;? super K, ? super V&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key, e.value); } if (modCount != mc) throw new ConcurrentModificationException(); }}@Overridepublic void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) { Node&lt;K,V&gt;[] tab; if (function == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) { e.value = function.apply(e.key, e.value); } } if (modCount != mc) throw new ConcurrentModificationException(); }} clone å’Œ åºåˆ—åŒ–æ–¹æ³•>folded clone123456789101112131415161718192021222324/* ------------------------------------------------------------ */// Cloning and serialization/** * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and * values themselves are not cloned. * è¿”å›æ­¤HashMapå®ä¾‹çš„æµ…å‰¯æœ¬ï¼šé”®å’Œå€¼æœ¬èº«ä¸ä¼šè¢«å…‹éš†ã€‚ * * @return a shallow copy of this map */@SuppressWarnings(&quot;unchecked&quot;)@Overridepublic Object clone() { HashMap&lt;K,V&gt; result; try { result = (HashMap&lt;K,V&gt;)super.clone(); } catch (CloneNotSupportedException e) { // this shouldn't happen, since we are Cloneable throw new InternalError(e); } result.reinitialize(); result.putMapEntries(this, false); return result;} >folded serialization ç”¨äºåºåˆ—åŒ–çš„ä¸€äº›æ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// These methods are also used when serializing HashSetsfinal float loadFactor() { return loadFactor; }final int capacity() { return (table != null) ? table.length : (threshold &gt; 0) ? threshold : DEFAULT_INITIAL_CAPACITY;}/** * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e., * serialize it). * å°†HashMapå®ä¾‹çš„çŠ¶æ€ä¿å­˜åˆ°æµä¸­ï¼ˆå³åºåˆ—åŒ–å®ƒï¼‰ã€‚ * * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the * bucket array) is emitted (int), followed by the * &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value * mappings), followed by the key (Object) and value (Object) * for each key-value mapping. The key-value mappings are * emitted in no particular order. */private void writeObject(java.io.ObjectOutputStream s) throws IOException { int buckets = capacity(); // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); s.writeInt(buckets); s.writeInt(size); internalWriteEntries(s);}/** * Reconstitute the {@code HashMap} instance from a stream (i.e., * deserialize it). * ä»æµä¸­é‡å»ºHashMapå®ä¾‹ï¼ˆå³ååºåˆ—åŒ–å®ƒï¼‰ã€‚ */private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) { // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) { @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } }} iterators è¿­ä»£æ–¹æ³•>folded HashIterator hashè¿­ä»£å™¨æŠ½è±¡å†…éƒ¨ç±»123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* ------------------------------------------------------------ */// iteratorsabstract class HashIterator { Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() { expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) { // advance to first entry do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); } } public final boolean hasNext() { return next != null; } final Node&lt;K,V&gt; nextNode() { Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) { do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); } return e; } public final void remove() { Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount; }} >folded HashIteratorçš„ä¸‰ä¸ªå­ç±»ï¼škeyã€valueã€æ˜ å°„è¿­ä»£å™¨1234567891011121314final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; { public final K next() { return nextNode().key; }}final class ValueIterator extends HashIterator implements Iterator&lt;V&gt; { public final V next() { return nextNode().value; }}final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; { public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }} spliterators åˆ†ç¦»å™¨>folded HashMapSpliteratoråˆ†ç¦»å™¨é™æ€å†…éƒ¨ç±»1234567891011121314151617181920212223242526272829303132333435363738/* ------------------------------------------------------------ */// spliteratorsstatic class HashMapSpliterator&lt;K,V&gt; { final HashMap&lt;K,V&gt; map; Node&lt;K,V&gt; current; // current node | å½“å‰èŠ‚ç‚¹ int index; // current index, modified on advance/split | å½“å‰ç´¢å¼•ï¼Œåœ¨ advance/split æ—¶ä¿®æ”¹ int fence; // one past last index | æœ€åä¸€ä¸ªç´¢å¼• int est; // size estimate | é¢„ä¼°å¤§å° int expectedModCount; // for comodification checks | é¢„æœŸä¿®æ”¹æ•°ï¼Œç”¨äºä¿®æ”¹æ£€æŸ¥ HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) { this.map = m; this.index = origin; this.fence = fence; this.est = est; this.expectedModCount = expectedModCount; } final int getFence() { // initialize fence and size on first use | ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶åˆå§‹åŒ–fenceå’Œestã€expectedModCount int hi; if ((hi = fence) &lt; 0) { HashMap&lt;K,V&gt; m = map; est = m.size; expectedModCount = m.modCount; Node&lt;K,V&gt;[] tab = m.table; hi = fence = (tab == null) ? 0 : tab.length; } return hi; } public final long estimateSize() { getFence(); // force init return (long) est; }} >folded KeySpliteratoråˆ†ç¦»å™¨1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071static final class KeySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;K&gt; { KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) { super(m, origin, fence, est, expectedModCount); } public KeySpliterator&lt;K,V&gt; trySplit() { int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); } public void forEachRemaining(Consumer&lt;? super K&gt; action) { int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) { mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; } else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) { Node&lt;K,V&gt; p = current; current = null; do { if (p == null) p = tab[i++]; else { action.accept(p.key); p = p.next; } } while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); } } public boolean tryAdvance(Consumer&lt;? super K&gt; action) { int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) { while (current != null || index &lt; hi) { if (current == null) current = tab[index++]; else { K k = current.key; current = current.next; action.accept(k); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } } } return false; } public int characteristics() { return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; }} >folded ValueSpliteratoråˆ†ç¦»å™¨12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static final class ValueSpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;V&gt; { ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) { super(m, origin, fence, est, expectedModCount); } public ValueSpliterator&lt;K,V&gt; trySplit() { int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); } public void forEachRemaining(Consumer&lt;? super V&gt; action) { int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) { mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; } else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) { Node&lt;K,V&gt; p = current; current = null; do { if (p == null) p = tab[i++]; else { action.accept(p.value); p = p.next; } } while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); } } public boolean tryAdvance(Consumer&lt;? super V&gt; action) { int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) { while (current != null || index &lt; hi) { if (current == null) current = tab[index++]; else { V v = current.value; current = current.next; action.accept(v); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } } } return false; } public int characteristics() { return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0); }} >folded EntrySpliteratoråˆ†ç¦»å™¨1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071static final class EntrySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; { EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) { super(m, origin, fence, est, expectedModCount); } public EntrySpliterator&lt;K,V&gt; trySplit() { int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); } public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) { int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) { mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; } else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) { Node&lt;K,V&gt; p = current; current = null; do { if (p == null) p = tab[i++]; else { action.accept(p); p = p.next; } } while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); } } public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) { int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) { while (current != null || index &lt; hi) { if (current == null) current = tab[index++]; else { Node&lt;K,V&gt; e = current; current = current.next; action.accept(e); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } } } return false; } public int characteristics() { return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; }} LinkedHashMap support LinkedHashMapæ”¯æŒ>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* ------------------------------------------------------------ */// LinkedHashMap support/* * The following package-protected methods are designed to be * overridden by LinkedHashMap, but not by any other subclass. * Nearly all other internal methods are also package-protected * but are declared final, so can be used by LinkedHashMap, view * classes, and HashSet. * ä¸‹é¢çš„å—ç¨‹åºåŒ…ä¿æŠ¤çš„æ–¹æ³•æ—¨åœ¨è¢«LinkedHashMapè¦†ç›–ï¼Œä½†ä¸èƒ½è¢«ä»»ä½•å…¶ä»–å­ç±»è¦†ç›–ã€‚ * å‡ ä¹æ‰€æœ‰å…¶ä»–å†…éƒ¨æ–¹æ³•ä¹Ÿå—ç¨‹åºåŒ…ä¿æŠ¤ï¼Œä½†éƒ½å£°æ˜ä¸ºfinalï¼Œå› æ­¤LinkedHashMapï¼Œè§†å›¾ç±»å’ŒHashSetå¯ä»¥ä½¿ç”¨å®ƒã€‚ */// Create a regular (non-tree) node | åˆ›å»ºä¸€ä¸ªå¸¸è§„ï¼ˆéæ ‘ï¼‰èŠ‚ç‚¹Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) { return new Node&lt;&gt;(hash, key, value, next);}// For conversion from TreeNodes to plain nodes | ç”¨äºä»TreeNodesè½¬æ¢ä¸ºå¸¸è§„èŠ‚ç‚¹Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) { return new Node&lt;&gt;(p.hash, p.key, p.value, next);}// Create a tree bin node | åˆ›å»ºä¸€ä¸ªæ ‘èŠ‚ç‚¹TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) { return new TreeNode&lt;&gt;(hash, key, value, next);}// For treeifyBin | è½¬åŒ–ä¸ºæ ‘èŠ‚ç‚¹TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) { return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);}/** * Reset to initial default state. Called by clone and readObject. * é‡ç½®ä¸ºåˆå§‹é»˜è®¤çŠ¶æ€ã€‚ ç”±cloneå’ŒreadObjectè°ƒç”¨ */void reinitialize() { table = null; entrySet = null; keySet = null; values = null; modCount = 0; threshold = 0; size = 0;}// Callbacks to allow LinkedHashMap post-actions | å…è®¸LinkedHashMapåå¤„ç†çš„å›è°ƒvoid afterNodeAccess(Node&lt;K,V&gt; p) { }void afterNodeInsertion(boolean evict) { }void afterNodeRemoval(Node&lt;K,V&gt; p) { }// Called only from writeObject, to ensure compatible ordering. | ä»…ä»writeObjectè°ƒç”¨ï¼Œä»¥ç¡®ä¿å…¼å®¹çš„é¡ºåºã€‚void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException { Node&lt;K,V&gt;[] tab; if (size &gt; 0 &amp;&amp; (tab = table) != null) { for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) { s.writeObject(e.key); s.writeObject(e.value); } } }} Tree bins æ ‘ç®±>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612/* ------------------------------------------------------------ */// Tree bins/** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. * æ ‘ç®±çš„Entryã€‚ ç»§æ‰¿LinkedHashMap.Entryï¼ˆè¿›è€Œæ‰©å±•Nodeï¼‰ï¼Œå› æ­¤å¯ä»¥ç”¨ä½œå¸¸è§„èŠ‚ç‚¹æˆ–é“¾æ¥èŠ‚ç‚¹çš„æ‰©å±•ã€‚ */static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; { TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) { super(hash, key, val, next); } /** * Returns root of tree containing this node. * è¿”å›åŒ…å«æ­¤èŠ‚ç‚¹çš„æ ‘çš„æ ¹èŠ‚ç‚¹ */ final TreeNode&lt;K,V&gt; root() { for (TreeNode&lt;K,V&gt; r = this, p;;) { if ((p = r.parent) == null) return r; r = p; } } /** * Ensures that the given root is the first node of its bin. * ç¡®ä¿ç»™å®šçš„æ ¹æ˜¯å…¶binçš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ */ static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) { int n; if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) { int index = (n - 1) &amp; root.hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; if (root != first) { Node&lt;K,V&gt; rn; tab[index] = root; TreeNode&lt;K,V&gt; rp = root.prev; if ((rn = root.next) != null) ((TreeNode&lt;K,V&gt;)rn).prev = rp; if (rp != null) rp.next = rn; if (first != null) first.prev = root; root.next = first; root.prev = null; } assert checkInvariants(root); } } /** * Finds the node starting at root p with the given hash and key. * The kc argument caches comparableClassFor(key) upon first use * comparing keys. * æ ¹æ®ç»™å®šçš„hashå’Œkey ä»æ ‘æ ¹èŠ‚ç‚¹på¼€å§‹æŸ¥æ‰¾è¯¥èŠ‚ç‚¹ã€‚ * kcå‚æ•°åœ¨é¦–æ¬¡æ¯”è¾ƒkeyæ—¶ä¼šç¼“å­˜comparableClassFor(key) */ final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) { TreeNode&lt;K,V&gt; p = this; do { int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; } while (p != null); return null; } /** * Calls find for root node. * è°ƒç”¨æŸ¥æ‰¾æ ¹èŠ‚ç‚¹ã€‚ */ final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) { return ((parent != null) ? root() : this).find(h, k, null); } /** * Tie-breaking utility for ordering insertions when equal * hashCodes and non-comparable. We don't require a total * order, just a consistent insertion rule to maintain * equivalence across rebalancings. Tie-breaking further than * necessary simplifies testing a bit. * Tie-breakingç¨‹åºï¼Œç”¨äºåœ¨hashCodesç›¸ç­‰ä¸”ä¸å¯æ¯”è¾ƒæ—¶å¯¹æ’å…¥è¿›è¡Œæ’åºã€‚ * æˆ‘ä»¬ä¸éœ€è¦æ€»çš„æ’åºï¼Œåªéœ€ä¸€ä¸ªä¸€è‡´çš„æ’å…¥è§„åˆ™å³å¯åœ¨é‡æ–°å¹³è¡¡æœŸé—´ä¿æŒç­‰æ•ˆã€‚ * Tie-breakingæ¯”ç®€åŒ–æµ‹è¯•æ›´æœ‰å¿…è¦ã€‚ */ static int tieBreakOrder(Object a, Object b) { int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d; } /** * Forms tree of the nodes linked from this node. * ä»è¯¥èŠ‚ç‚¹é“¾æ¥çš„èŠ‚ç‚¹çš„è¡¨å•æ ‘ã€‚- æ ‘åŒ–èŠ‚ç‚¹ï¼šéæ ‘èŠ‚ç‚¹ -&gt; æ ‘èŠ‚ç‚¹ * @return root of tree */ final void treeify(Node&lt;K,V&gt;[] tab) { TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) { next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) { x.parent = null; x.red = false; root = x; } else { K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = root;;) { int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) { x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; } } } } moveRootToFront(tab, root); } /** * Returns a list of non-TreeNodes replacing those linked from * this node. * è¿”å›éTreeNodeåˆ—è¡¨ï¼Œè¯¥åˆ—è¡¨æ›¿æ¢ä»è¯¥èŠ‚ç‚¹é“¾æ¥çš„éTreeNodeã€‚- å»æ ‘åŒ–ï¼šæ ‘èŠ‚ç‚¹ -&gt; éæ ‘èŠ‚ç‚¹ */ final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) { Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) { Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; } return hd; } /** * Tree version of putVal. */ final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) { Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) { int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) { if (!searched) { TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; } dir = tieBreakOrder(k, pk); } TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) { Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; } } } /** * Removes the given node, that must be present before this call. * This is messier than typical red-black deletion code because we * cannot swap the contents of an interior node with a leaf * successor that is pinned by &quot;next&quot; pointers that are accessible * independently during traversal. So instead we swap the tree * linkages. If the current tree appears to have too few nodes, * the bin is converted back to a plain bin. (The test triggers * somewhere between 2 and 6 nodes, depending on tree structure). * åˆ é™¤ç»™å®šèŠ‚ç‚¹å¿…é¡»åœ¨æ­¤è°ƒç”¨ä¹‹å‰ã€‚ * è¿™æ¯”å…¸å‹çš„çº¢é»‘æ ‘åˆ é™¤ä»£ç æ›´ä¸ºæ··ä¹±ï¼Œå› ä¸ºæˆ‘ä»¬ä¸èƒ½å°†å†…éƒ¨èŠ‚ç‚¹çš„å†…å®¹ä¸å¶ç»§æ‰¿è€…äº¤æ¢ï¼Œå¶ç»§æ‰¿è€…æ˜¯ç”±åœ¨éå†æœŸé—´å¯ç‹¬ç«‹è®¿é—®çš„â€œä¸‹ä¸€ä¸ªâ€æŒ‡é’ˆå›ºå®šçš„ã€‚ * å› æ­¤ï¼Œæˆ‘ä»¬äº¤æ¢æ ‘é“¾æ¥ã€‚å¦‚æœå½“å‰æ ‘çš„èŠ‚ç‚¹ä¼¼ä¹å¤ªå°‘ï¼Œåˆ™å°†æ ‘ç®±è½¬æ¢å›æ™®é€šç®±ã€‚ ï¼ˆè¯¥æµ‹è¯•è§¦å‘åœ¨2åˆ°6ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„æŸä¸ªä½ç½®ï¼Œå…·ä½“å–å†³äºæ ‘çš„ç»“æ„ï¼‰ã€‚ */ final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) { int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) &amp; hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); if (root == null || root.right == null || (rl = root.left) == null || rl.left == null) { tab[index] = first.untreeify(map); // too small return; } TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) { TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor | æŸ¥æ‰¾ç»§ä»»è€… s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors | äº¤æ¢é¢œè‰² TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; if (s == pr) { // p was s's direct parent | pæ˜¯sçš„ç›´æ¥çˆ¶çº§ p.parent = s; s.right = p; } else { TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) { if (s == sp.left) sp.left = p; else sp.right = p; } if ((s.right = pr) != null) pr.parent = s; } p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; } else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) { TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; } TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) { // detach | åˆ†ç¦» TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) { if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; } } if (movable) moveRootToFront(tab, r); } /** * Splits nodes in a tree bin into lower and upper tree bins, * or untreeifies if now too small. Called only from resize; * see above discussion about split bits and indices. * å°†æ ‘ç®±ä¸­çš„èŠ‚ç‚¹æ‹†åˆ†ä¸ºè¾ƒé«˜å’Œè¾ƒä½çš„æ ‘ç®±ï¼Œå¦‚æœç°åœ¨å¤ªå°ï¼Œåˆ™å–æ¶ˆæ ‘åŒ–ã€‚ä»…è¢«resizeè°ƒç”¨ï¼› * è¯·å‚é˜…ä¸Šé¢æœ‰å…³æ‹†åˆ†ä½å’Œç´¢å¼•çš„è®¨è®ºã€‚ * * @param map the map * @param tab the table for recording bin heads * @param index the index of the table being split * @param bit the bit of hash to split on */ final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) { TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order | é‡æ–°é“¾æ¥åˆ°loå’Œhiåˆ—è¡¨ï¼Œä¿ç•™é¡ºåº TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) { next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) { if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; } else { if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; } } if (loHead != null) { if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else { tab[index] = loHead; if (hiHead != null) // (else is already treeified) | å…¶ä»–å·²ç»è¢«æ ‘åŒ–äº† loHead.treeify(tab); } } if (hiHead != null) { if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else { tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); } } } /* ------------------------------------------------------------ */ // Red-black tree methods, all adapted from CLR | çº¢é»‘æ ‘æ–¹æ³•ï¼Œå…¨éƒ¨æ”¹ç¼–è‡ªCLR static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) { TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) { if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; } return root; } static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) { TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) { if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; } return root; } static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) { x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) { if ((xp = x.parent) == null) { x.red = false; return x; } else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) { if ((xppr = xpp.right) != null &amp;&amp; xppr.red) { xppr.red = false; xp.red = false; xpp.red = true; x = xpp; } else { if (x == xp.right) { root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; } if (xp != null) { xp.red = false; if (xpp != null) { xpp.red = true; root = rotateRight(root, xpp); } } } } else { if (xppl != null &amp;&amp; xppl.red) { xppl.red = false; xp.red = false; xpp.red = true; x = xpp; } else { if (x == xp.left) { root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; } if (xp != null) { xp.red = false; if (xpp != null) { xpp.red = true; root = rotateLeft(root, xpp); } } } } } } static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) { for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) { if (x == null || x == root) return root; else if ((xp = x.parent) == null) { x.red = false; return x; } else if (x.red) { x.red = false; return root; } else if ((xpl = xp.left) == x) { if ((xpr = xp.right) != null &amp;&amp; xpr.red) { xpr.red = false; xp.red = true; root = rotateLeft(root, xp); xpr = (xp = x.parent) == null ? null : xp.right; } if (xpr == null) x = xp; else { TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) { xpr.red = true; x = xp; } else { if (sr == null || !sr.red) { if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; } if (xpr != null) { xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; } if (xp != null) { xp.red = false; root = rotateLeft(root, xp); } x = root; } } } else { // symmetric | å¯¹ç§°çš„ if (xpl != null &amp;&amp; xpl.red) { xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; } if (xpl == null) x = xp; else { TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) { xpl.red = true; x = xp; } else { if (sl == null || !sl.red) { if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; } if (xpl != null) { xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; } if (xp != null) { xp.red = false; root = rotateRight(root, xp); } x = root; } } } } } /** * Recursive invariant check * é€’å½’ä¸å˜æ£€æŸ¥ */ static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) { TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right, tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next; if (tb != null &amp;&amp; tb.next != t) return false; if (tn != null &amp;&amp; tn.prev != t) return false; if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right) return false; if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash)) return false; if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash)) return false; if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red) return false; if (tl != null &amp;&amp; !checkInvariants(tl)) return false; if (tr != null &amp;&amp; !checkInvariants(tr)) return false; return true; }}","link":"/2020/10/15/source_code/hashmap/"},{"title":"Lock æºç ç¿»è¯‘","text":"ã€å°šæœªå®Œç»“ã€‘**åŸºäºJDK1.8** ç‰ˆæƒå£°æ˜>folded1234567891011121314/* * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * Oracle ä¸“æœ‰/æœºå¯†ã€‚ ä½¿ç”¨é¡»éµå®ˆè®¸å¯æ¡æ¬¾ã€‚ *//* * Written by Doug Lea with assistance from members of JCP JSR-166 * Expert Group and released to the public domain, as explained at * http://creativecommons.org/publicdomain/zero/1.0/ * ç”±Doug Leaåœ¨JCP JSR-166ä¸“å®¶ç»„æˆå‘˜çš„ååŠ©ä¸‹æ’°å†™ï¼Œå¹¶å·²å‘å¸ƒåˆ°å…¬å…±é¢†åŸŸï¼Œ * å¦‚http://creativecommons.org/publicdomain/zero/1.0/æ‰€è¿° */package java.util.concurrent.locks;import java.util.concurrent.TimeUnit; ç±»è¯´æ˜>folded åŸ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * {@code Lock} implementations provide more extensive locking * operations than can be obtained using {@code synchronized} methods * and statements. They allow more flexible structuring, may have * quite different properties, and may support multiple associated * {@link Condition} objects. * * &lt;p&gt;A lock is a tool for controlling access to a shared resource by * multiple threads. Commonly, a lock provides exclusive access to a * shared resource: only one thread at a time can acquire the lock and * all access to the shared resource requires that the lock be * acquired first. However, some locks may allow concurrent access to * a shared resource, such as the read lock of a {@link ReadWriteLock}. * * &lt;p&gt;The use of {@code synchronized} methods or statements provides * access to the implicit monitor lock associated with every object, but * forces all lock acquisition and release to occur in a block-structured way: * when multiple locks are acquired they must be released in the opposite * order, and all locks must be released in the same lexical scope in which * they were acquired. * * &lt;p&gt;While the scoping mechanism for {@code synchronized} methods * and statements makes it much easier to program with monitor locks, * and helps avoid many common programming errors involving locks, * there are occasions where you need to work with locks in a more * flexible way. For example, some algorithms for traversing * concurrently accessed data structures require the use of * &amp;quot;hand-over-hand&amp;quot; or &amp;quot;chain locking&amp;quot;: you * acquire the lock of node A, then node B, then release A and acquire * C, then release B and acquire D and so on. Implementations of the * {@code Lock} interface enable the use of such techniques by * allowing a lock to be acquired and released in different scopes, * and allowing multiple locks to be acquired and released in any * order. * * &lt;p&gt;With this increased flexibility comes additional * responsibility. The absence of block-structured locking removes the * automatic release of locks that occurs with {@code synchronized} * methods and statements. In most cases, the following idiom * should be used: * * &lt;pre&gt; {@code * Lock l = ...; * l.lock(); * try { * // access the resource protected by this lock * } finally { * l.unlock(); * }}&lt;/pre&gt; * * When locking and unlocking occur in different scopes, care must be * taken to ensure that all code that is executed while the lock is * held is protected by try-finally or try-catch to ensure that the * lock is released when necessary. * * &lt;p&gt;{@code Lock} implementations provide additional functionality * over the use of {@code synchronized} methods and statements by * providing a non-blocking attempt to acquire a lock ({@link * #tryLock()}), an attempt to acquire the lock that can be * interrupted ({@link #lockInterruptibly}, and an attempt to acquire * the lock that can timeout ({@link #tryLock(long, TimeUnit)}). * * &lt;p&gt;A {@code Lock} class can also provide behavior and semantics * that is quite different from that of the implicit monitor lock, * such as guaranteed ordering, non-reentrant usage, or deadlock * detection. If an implementation provides such specialized semantics * then the implementation must document those semantics. * * &lt;p&gt;Note that {@code Lock} instances are just normal objects and can * themselves be used as the target in a {@code synchronized} statement. * Acquiring the * monitor lock of a {@code Lock} instance has no specified relationship * with invoking any of the {@link #lock} methods of that instance. * It is recommended that to avoid confusion you never use {@code Lock} * instances in this way, except within their own implementation. * * &lt;p&gt;Except where noted, passing a {@code null} value for any * parameter will result in a {@link NullPointerException} being * thrown. * * &lt;h3&gt;Memory Synchronization&lt;/h3&gt; * * &lt;p&gt;All {@code Lock} implementations &lt;em&gt;must&lt;/em&gt; enforce the same * memory synchronization semantics as provided by the built-in monitor * lock, as described in * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4&quot;&gt; * The Java Language Specification (17.4 Memory Model)&lt;/a&gt;: * &lt;ul&gt; * &lt;li&gt;A successful {@code lock} operation has the same memory * synchronization effects as a successful &lt;em&gt;Lock&lt;/em&gt; action. * &lt;li&gt;A successful {@code unlock} operation has the same * memory synchronization effects as a successful &lt;em&gt;Unlock&lt;/em&gt; action. * &lt;/ul&gt; * * Unsuccessful locking and unlocking operations, and reentrant * locking/unlocking operations, do not require any memory * synchronization effects. * * &lt;h3&gt;Implementation Considerations&lt;/h3&gt; * * &lt;p&gt;The three forms of lock acquisition (interruptible, * non-interruptible, and timed) may differ in their performance * characteristics, ordering guarantees, or other implementation * qualities. Further, the ability to interrupt the &lt;em&gt;ongoing&lt;/em&gt; * acquisition of a lock may not be available in a given {@code Lock} * class. Consequently, an implementation is not required to define * exactly the same guarantees or semantics for all three forms of * lock acquisition, nor is it required to support interruption of an * ongoing lock acquisition. An implementation is required to clearly * document the semantics and guarantees provided by each of the * locking methods. It must also obey the interruption semantics as * defined in this interface, to the extent that interruption of lock * acquisition is supported: which is either totally, or only on * method entry. * * &lt;p&gt;As interruption generally implies cancellation, and checks for * interruption are often infrequent, an implementation can favor responding * to an interrupt over normal method return. This is true even if it can be * shown that the interrupt occurred after another action may have unblocked * the thread. An implementation should document this behavior. * * @see ReentrantLock * @see Condition * @see ReadWriteLock * * @since 1.5 * @author Doug Lea */ >folded è¯‘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * ä¸ä½¿ç”¨åŒæ­¥æ–¹æ³•å’Œè¯­å¥ç›¸æ¯”ï¼Œé”å®ç°æä¾›äº†æ›´å¹¿æ³›çš„é”æ“ä½œã€‚ * å®ƒä»¬å…è®¸æ›´çµæ´»çš„ç»“æ„ï¼Œå¯ä»¥å…·æœ‰å®Œå…¨ä¸åŒçš„å±æ€§ï¼Œå¹¶ä¸”å¯ä»¥æ”¯æŒå¤šä¸ªå…³è”çš„Condition(æ¡ä»¶)å¯¹è±¡ã€‚ * * é”æ˜¯ä¸€ç§ç”¨äºæ§åˆ¶å¤šä¸ªçº¿ç¨‹å¯¹å…±äº«èµ„æºçš„è®¿é—®çš„å·¥å…·ã€‚ * é€šå¸¸ï¼Œé”æä¾›å¯¹å…±äº«èµ„æºçš„ç‹¬å è®¿é—®ï¼šä¸€æ¬¡åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è·å–è¯¥é”ï¼Œè€Œå¯¹å…±äº«èµ„æºçš„æ‰€æœ‰è®¿é—®éƒ½éœ€è¦é¦–å…ˆè·å–è¯¥é”ã€‚ * ä½†æ˜¯ï¼ŒæŸäº›é”å¯èƒ½å…è®¸å¹¶å‘è®¿é—®å…±äº«èµ„æºï¼Œä¾‹å¦‚ReadWriteLockçš„è¯»é”ã€‚ * * ä½¿ç”¨åŒæ­¥æ–¹æ³•æˆ–è¯­å¥å¯è®¿é—®ä¸æ¯ä¸ªå¯¹è±¡å…³è”çš„éšå¼ç›‘è§†å™¨é”ï¼Œä½†ä¼šå¼ºåˆ¶æ‰€æœ‰é”çš„è·å–å’Œé‡Šæ”¾ä»¥å—ç»“æ„æ–¹å¼è¿›è¡Œï¼š * å½“è·å–å¤šä¸ªé”æ—¶ï¼Œå®ƒä»¬å¿…é¡»ä»¥ç›¸åçš„é¡ºåºé‡Šæ”¾ï¼Œå¹¶ä¸” æ‰€æœ‰é”å¿…é¡»åœ¨è·å¾—å®ƒä»¬çš„ç›¸åŒè¯æ±‡èŒƒå›´å†…é‡Šæ”¾ã€‚ * * å°½ç®¡ç”¨äºsynchronizedåŒæ­¥æ–¹æ³•å’Œè¯­å¥çš„ä½œç”¨åŸŸæœºåˆ¶ä½¿å¾—ç”¨ç›‘è§†å™¨é”çš„ç¼–ç¨‹å˜å¾—æ›´åŠ å®¹æ˜“ï¼Œå¹¶æœ‰åŠ©äºé¿å…è®¸å¤šå¸¸è§çš„æ¶‰åŠé”çš„ç¼–ç¨‹é”™è¯¯ï¼Œ * ä½†åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ‚¨éœ€è¦ä»¥æ›´çµæ´»çš„æ–¹å¼ä½¿ç”¨é”ã€‚ * ä¾‹å¦‚ï¼ŒæŸäº›ç”¨äºéå†å¹¶å‘è®¿é—®çš„æ•°æ®ç»“æ„çš„ç®—æ³•éœ€è¦ä½¿ç”¨â€œç§»äº¤â€æˆ–â€œé“¾é”â€ï¼šæ‚¨è·å–èŠ‚ç‚¹Açš„é”ï¼Œç„¶åè·å–èŠ‚ç‚¹Bçš„é”ï¼Œç„¶åé‡Šæ”¾Aå¹¶è·å–Cï¼Œç„¶åé‡Šæ”¾B å¹¶è·å¾—Dç­‰ã€‚ * Lockæ¥å£çš„å®ç°é€šè¿‡å…è®¸åœ¨ä¸åŒèŒƒå›´å†…è·å–å’Œé‡Šæ”¾é”ï¼Œå¹¶å…è®¸ä»¥ä»»æ„é¡ºåºè·å–å’Œé‡Šæ”¾å¤šä¸ªé”ï¼Œä»è€Œå¯ç”¨äº†æ­¤ç±»æŠ€æœ¯ã€‚ * * çµæ´»æ€§çš„æé«˜å¸¦æ¥äº†é¢å¤–çš„è´£ä»»ã€‚ç¼ºå°‘å—ç»“æ„é”å®šå°†æ¶ˆé™¤åŒæ­¥æ–¹æ³•å’Œè¯­å¥å‘ç”Ÿçš„è‡ªåŠ¨é”å®šé‡Šæ”¾ã€‚ * åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œåº”ä½¿ç”¨ä»¥ä¸‹æƒ¯ç”¨æ³•ï¼š * * Lock l = ...; * l.lock(); * try { * // access the resource protected by this lock * } finally { * l.unlock(); * } * * å½“é”å®šå’Œè§£é”å‘ç”Ÿåœ¨ä¸åŒçš„èŒƒå›´å†…æ—¶ï¼Œå¿…é¡»å°å¿ƒä»¥ç¡®ä¿é€šè¿‡try-finallyæˆ–try-catchä¿æŠ¤æŒæœ‰é”æ—¶æ‰§è¡Œçš„æ‰€æœ‰ä»£ç ï¼Œ * ä»¥ç¡®ä¿åœ¨å¿…è¦æ—¶é‡Šæ”¾é”ã€‚ * * Lockå®ç°æä¾›äº†æ¯”synchronizedåŒæ­¥æ–¹æ³•å’Œè¯­å¥ä¹‹å¤–æ›´å¤šçš„åŠŸèƒ½ã€‚å®ƒå¯ä»¥éé˜»å¡çš„å°è¯•å»è·å–é”(tryLock())ï¼Œå¯ä»¥è·å–å¯è¢«ä¸­æ–­çš„é”lockInterruptiblyï¼Œ * åŒ…æ‹¬å¯ä»¥è®¾ç½®è¶…æ—¶æ—¶é—´çš„é”(tryLock(longï¼ŒTimeUnit))ã€‚ * * Lockç±»è¿˜å¯ä»¥æä¾›ä¸éšå¼ç›‘è§†å™¨é”å®šå®Œå…¨ä¸åŒçš„è¡Œä¸ºå’Œè¯­ä¹‰ï¼Œä¾‹å¦‚ä¿è¯é¡ºåºï¼Œä¸å¯é‡ç”¨æˆ–æ­»é”æ£€æµ‹ã€‚ * å¦‚æœå®ç°æä¾›äº†è¿™ç§ç‰¹æ®Šçš„è¯­ä¹‰ï¼Œåˆ™å®ç°å¿…é¡»è®°å½•è¿™äº›è¯­ä¹‰ã€‚ * * è¯·æ³¨æ„ï¼ŒLockå®ä¾‹åªæ˜¯æ™®é€šå¯¹è±¡ï¼Œå®ƒä»¬æœ¬èº«å¯ä»¥ç”¨ä½œåŒæ­¥è¯­å¥ä¸­çš„ç›®æ ‡ã€‚è·å–Lockå®ä¾‹çš„ç›‘è§†å™¨é”ä¸è°ƒç”¨è¯¥å®ä¾‹çš„ä»»ä½•é”æ–¹æ³•æ²¡æœ‰æŒ‡å®šçš„å…³ç³»ã€‚ * å»ºè®®é¿å…æ··æ·†ï¼Œé™¤éåœ¨è‡ªå·±çš„å®ç°ä¸­ä½¿ç”¨ï¼Œå¦åˆ™ä¸è¦ä»¥è¿™ç§æ–¹å¼ä½¿ç”¨Lockå®ä¾‹ã€‚ * * é™¤éå¦æœ‰è¯´æ˜ï¼Œå¦åˆ™ä¸ºä»»ä½•å‚æ•°ä¼ é€’nullå€¼éƒ½å°†å¼•å‘NullPointerExceptionã€‚ * * å†…å­˜åŒæ­¥ * * æ‰€æœ‰é”å®ç°å¿…é¡»å¼ºåˆ¶æ‰§è¡Œä¸å†…ç½®ç›‘è§†å™¨é”æ‰€æä¾›çš„ç›¸åŒçš„å†…å­˜åŒæ­¥è¯­ä¹‰ï¼Œå¦‚Javaè¯­è¨€è§„èŒƒï¼ˆ17.4å†…å­˜æ¨¡å‹ï¼‰ä¸­æ‰€è¿°ï¼š * * * * * * ä¸æˆåŠŸçš„é”å®šå’Œè§£é”æ“ä½œä»¥åŠå¯é‡å…¥çš„é”å®š/è§£é”æ“ä½œä¸éœ€è¦ä»»ä½•å†…å­˜åŒæ­¥æ•ˆæœã€‚ * * å®ç°æ³¨æ„äº‹é¡¹ * * é”è·å–çš„ä¸‰ç§å½¢å¼ï¼ˆå¯ä¸­æ–­ï¼Œä¸å¯ä¸­æ–­å’Œå®šæ—¶ï¼‰å¯èƒ½åœ¨æ€§èƒ½ç‰¹å¾ï¼Œè®¢è´­ä¿è¯æˆ–å…¶ä»–å®ç°è´¨é‡ä¸Šæœ‰æ‰€ä¸åŒã€‚ * æ­¤å¤–ï¼Œåœ¨ç»™å®šçš„Lockç±»ä¸­ï¼Œå¯èƒ½æ— æ³•æä¾›ä¸­æ–­æ­£åœ¨è¿›è¡Œçš„é”å®šçš„åŠŸèƒ½ã€‚å› æ­¤ï¼Œä¸éœ€è¦ä¸ºæ‰€æœ‰ä¸‰ç§å½¢å¼çš„é”è·å–å®šä¹‰å®Œå…¨ç›¸åŒçš„ä¿è¯æˆ–è¯­ä¹‰çš„å®ç°ï¼Œ * ä¹Ÿä¸éœ€è¦æ”¯æŒæ­£åœ¨è¿›è¡Œçš„é”è·å–çš„ä¸­æ–­ã€‚éœ€è¦ä¸€ä¸ªå®ç°æ¥æ¸…æ¥šåœ°è®°å½•æ¯ä¸ªé”å®šæ–¹æ³•æä¾›çš„è¯­ä¹‰å’Œä¿è¯ã€‚ * åœ¨æ”¯æŒé”è·å–ä¸­æ–­çš„èŒƒå›´å†…ï¼Œå®ƒè¿˜å¿…é¡»æœä»æ­¤æ¥å£ä¸­å®šä¹‰çš„ä¸­æ–­è¯­ä¹‰ï¼šå…¨éƒ¨æˆ–ä»…åœ¨æ–¹æ³•è¾“å…¥æ—¶æ‰è¿™æ ·åšã€‚ * * @see ReentrantLock * @see Condition * @see ReadWriteLock * * @since 1.5 * @author Doug Lea */ ç±»ä¸»ä½“æ¥å£æ–¹æ³•>folded lock è·å–é”1234567891011121314151617181920212223public interface Lock { /** * Acquires the lock. * è·å–é” * * &lt;p&gt;If the lock is not available then the current thread becomes * disabled for thread scheduling purposes and lies dormant until the * lock has been acquired. * å¦‚æœè¯¥é”ä¸å¯ç”¨ï¼Œåˆ™å‡ºäºçº¿ç¨‹è°ƒåº¦ç›®çš„ï¼Œå½“å‰çº¿ç¨‹å°†è¢«ç¦ç”¨ï¼Œå¹¶å¤„äºä¼‘çœ çŠ¶æ€ï¼Œç›´åˆ°è·å¾—è¯¥é”ä¸ºæ­¢ã€‚ * * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt; * å®ç°æ³¨æ„äº‹é¡¹ * * &lt;p&gt;A {@code Lock} implementation may be able to detect erroneous use * of the lock, such as an invocation that would cause deadlock, and * may throw an (unchecked) exception in such circumstances. The * circumstances and the exception type must be documented by that * {@code Lock} implementation. * é”å®ç°å¯èƒ½èƒ½å¤Ÿæ£€æµ‹åˆ°é”çš„é”™è¯¯ä½¿ç”¨ï¼Œä¾‹å¦‚å¯èƒ½å¯¼è‡´æ­»é”çš„è°ƒç”¨ï¼Œå¹¶ä¸”åœ¨è¿™ç§æƒ…å†µä¸‹å¯èƒ½å¼•å‘ï¼ˆæœªç»æ£€æŸ¥çš„ï¼‰å¼‚å¸¸ã€‚ * è¯¥Lockå®ç°å¿…é¡»è®°å½•æƒ…å†µå’Œå¼‚å¸¸ç±»å‹ã€‚ */ void lock(); >folded lockInterruptibly è·å–é”ï¼Œé™¤éå½“å‰çº¿ç¨‹è¢«ä¸­æ–­12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Acquires the lock unless the current thread is * {@linkplain Thread#interrupt interrupted}. * è·å–é”ï¼Œé™¤éå½“å‰çº¿ç¨‹è¢«ä¸­æ–­ã€‚ * * &lt;p&gt;Acquires the lock if it is available and returns immediately. * è·å–é”ï¼ˆå¦‚æœæœ‰ï¼‰å¹¶ç«‹å³è¿”å›ã€‚ * * &lt;p&gt;If the lock is not available then the current thread becomes * disabled for thread scheduling purposes and lies dormant until * one of two things happens: * * &lt;ul&gt; * &lt;li&gt;The lock is acquired by the current thread; or * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts} the * current thread, and interruption of lock acquisition is supported. * &lt;/ul&gt; * * &lt;p&gt;If the current thread: * &lt;ul&gt; * &lt;li&gt;has its interrupted status set on entry to this method; or * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while acquiring the * lock, and interruption of lock acquisition is supported, * &lt;/ul&gt; * then {@link InterruptedException} is thrown and the current thread's * interrupted status is cleared. * * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt; * * &lt;p&gt;The ability to interrupt a lock acquisition in some * implementations may not be possible, and if possible may be an * expensive operation. The programmer should be aware that this * may be the case. An implementation should document when this is * the case. * * &lt;p&gt;An implementation can favor responding to an interrupt over * normal method return. * * &lt;p&gt;A {@code Lock} implementation may be able to detect * erroneous use of the lock, such as an invocation that would * cause deadlock, and may throw an (unchecked) exception in such * circumstances. The circumstances and the exception type must * be documented by that {@code Lock} implementation. * * @throws InterruptedException if the current thread is * interrupted while acquiring the lock (and interruption * of lock acquisition is supported) */void lockInterruptibly() throws InterruptedException; >folded DEFAULT_LOAD_FACTOR é»˜è®¤è´Ÿè½½å› å­12345/** * The load factor used when none specified in constructor. * åœ¨æ„é€ å‡½æ•°ä¸­æœªæŒ‡å®šæ—¶ä½¿ç”¨çš„è´Ÿè½½ç³»æ•°ã€‚é»˜è®¤0.75 */static final float DEFAULT_LOAD_FACTOR = 0.75f; >folded TREEIFY_THRESHOLD æ ‘åŒ–é˜ˆå€¼1234567891011/** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. * é€‰æ‹©ä½¿ç”¨æ ‘ç»“æ„è€Œä¸æ˜¯åˆ—è¡¨ç»“æ„çš„è®¡æ•°é˜ˆå€¼ã€‚æ¡¶é‡Œå…ƒç´ æ·»åŠ åˆ°è‡³å°‘å…·æœ‰è¿™ä¹ˆå¤šæ—¶ï¼Œæ¡¶çš„ç»“æ„ä¼šè½¬æ¢ä¸ºæ ‘ç»“æ„ã€‚ * è¯¥å€¼å¿…é¡»å¤§äº2ï¼Œå¹¶ä¸”è‡³å°‘æ˜¯8æ‰èƒ½ä¸æ ‘åˆ é™¤ä¸­çš„å‡è®¾ï¼ˆå³æ”¶ç¼©æ—¶è½¬æ¢å›åŸå§‹åˆ—è¡¨ç»“æ„çš„æ¡¶ï¼‰ç›¸å•®åˆ */static final int TREEIFY_THRESHOLD = 8; >folded UNTREEIFY_THRESHOLD å»æ ‘åŒ–é˜ˆå€¼1234567/** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. * åœ¨resizeæ“ä½œæœŸé—´ç”¨äºå»æ ‘åŒ–ï¼ˆæ‹†åˆ†ï¼‰ç®±çš„è®¡æ•°é˜ˆå€¼ã€‚åº”å°äºTREEIFY_THRESHOLDï¼ˆæ ‘åŒ–é˜ˆå€¼ï¼‰ï¼Œå¹¶ä¸”æœ€å¤§ä¸º6ä»¥ä¸åˆ é™¤æ—¶çš„æ”¶ç¼©æ£€æµ‹ç›¸å•®åˆã€‚ */static final int UNTREEIFY_THRESHOLD = 6; >folded MIN_TREEIFY_CAPACITY æ ‘ç»“æ„å­˜åœ¨æ—¶æœ€å°tableè¡¨å®¹é‡123456789/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. * æ ‘ç»“æ„å­˜åœ¨çš„æœ€å°è¡¨å®¹é‡ã€‚ï¼ˆå¦åˆ™ï¼Œå¦‚æœæ¡¶ä¸­çš„èŠ‚ç‚¹è¿‡å¤šï¼Œåˆ™å°†è°ƒæ•´è¡¨çš„å¤§å° - å¢åŠ tableæ•°ç»„é•¿åº¦ã€‚ï¼‰ * åº”è‡³å°‘ä¸º 4 * TREEIFY_THRESHOLDï¼Œä»¥é¿å…è°ƒæ•´å¤§å°å’Œæ ‘åŒ–é˜ˆå€¼ä¹‹é—´å‘ç”Ÿå†²çªã€‚ */static final int MIN_TREEIFY_CAPACITY = 64; é™æ€å†…éƒ¨ç±»>folded Node æ™®é€šèŠ‚ç‚¹123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) * åŸºæœ¬å“ˆå¸Œç®±èŠ‚ç‚¹ï¼Œç”¨äºå¤§å¤šæ•°æ¡ç›®ã€‚ï¼ˆæœ‰å…³TreeNodeå­ç±»çš„ä¿¡æ¯ï¼Œè¯·å‚è§ä¸‹æ–‡ï¼›æœ‰å…³Entryå­ç±»çš„ä¿¡æ¯ï¼Œè¯·å‚è§LinkedHashMapã€‚ï¼‰ * èŠ‚ç‚¹å¯¹è±¡åŒ…å«å››ä¸ªå±æ€§ï¼škeyå€¼çš„hashå€¼ã€keyå€¼ã€æ˜ å°„çš„å€¼valueã€ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å¯¹è±¡ */static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + &quot;=&quot; + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; }} é™æ€å·¥å…·æ–¹æ³•>folded hash è®¡ç®—hashå€¼1234567891011121314151617181920212223242526272829303132333435363738394041424344/* ---------------- Static utilities -------------- *//** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don't benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. * è®¡ç®—key.hashCode()å¹¶å°†å“ˆå¸Œçš„è¾ƒé«˜ä½ç‰¹å¾ï¼ˆXORï¼‰æ‰©å±•åˆ°è¾ƒä½ä½ä¸­ã€‚ * ç”±äºè¯¥è¡¨ä½¿ç”¨2çš„å¹‚æ¬¡æ©ç ï¼Œå› æ­¤ä»…åœ¨å½“å‰æ©ç ä¸Šæ–¹çš„ä½ä¸­å‘ç”Ÿå˜åŒ–çš„å“ˆå¸Œé›†å°†å§‹ç»ˆå‘ç”Ÿå†²çªã€‚ * ï¼ˆä¼—æ‰€å‘¨çŸ¥çš„ä¾‹å­æ˜¯åœ¨å°è¡¨ä¸­åŒ…å«è¿ç»­æ•´æ•°çš„Floaté”®é›†ã€‚ï¼‰å› æ­¤ï¼Œæˆ‘ä»¬åº”ç”¨äº†ä¸€ç§å˜æ¢ï¼Œå°†å‘ä¸‹æ‰©å±•è¾ƒé«˜ä½çš„å½±å“ã€‚ * åœ¨é€Ÿåº¦ï¼Œå®ç”¨æ€§å’Œä½æ‰©å±•è´¨é‡ä¹‹é—´éœ€è¦æƒè¡¡ã€‚ç”±äºè®¸å¤šå¸¸è§çš„å“ˆå¸Œé›†å·²ç»åˆç†åˆ†å¸ƒï¼ˆå› æ­¤æ— æ³•ä»æ‰©å±•ä¸­å—ç›Šï¼‰ï¼Œå¹¶ä¸”ç”±äºæˆ‘ä»¬ä½¿ç”¨æ ‘æ¥å¤„ç†å®¹å™¨ä¸­çš„å¤§é‡å†²çªï¼Œ * å› æ­¤æˆ‘ä»¬ä»…ä»¥æœ€ä¾¿å®œçš„æ–¹å¼å¯¹ä¸€äº›ç§»ä½åçš„ä½è¿›è¡ŒXORï¼ˆå¼‚æˆ–è¿ç®—ï¼‰ï¼Œä»¥å‡å°‘ç³»ç»ŸæŸå¤±ï¼Œä»¥åŠåˆå¹¶è¾ƒé«˜ä½çš„å½±å“ï¼Œå¦åˆ™ç”±äºè¡¨èŒƒå›´çš„é™åˆ¶ï¼Œè¿™äº›ä½å°†æ°¸è¿œä¸ä¼šåœ¨ç´¢å¼•è®¡ç®—ä¸­ä½¿ç”¨ã€‚ * * æ„æ€å°±æ˜¯å°†é«˜ä½çš„äºŒè¿›åˆ¶ç‰¹å¾åˆå¹¶åˆ°ä½ä½ç‰¹å¾ä¸­ï¼ˆè¿™ä¹ˆåšçš„åŸå› æ˜¯åé¢å®šä½æ•°ç»„ä¸‹æ ‡ä½¿ç”¨çš„æ–¹æ³•æ˜¯ï¼š * hash &amp; (tab.length-1)ï¼Œè¿™ä¸ªäºŒè¿›åˆ¶è¿ç®—ä½¿å¾—hashé«˜ä½è¢«å±è”½æ²¡æœ‰èµ·ä½œç”¨ï¼Œæ‰€ä»¥ä¸ºäº†ä¿ç•™é«˜ä½çš„ç‰¹å¾å’Œå½±å“è€Œè¿›è¡Œäº†æ‰©å±•æ“ä½œï¼Œ * ä¿ç•™é«˜ä½ç‰¹å¾å¯ä»¥å‡å°hashç¢°æ’ï¼‰ã€‚ * ç¤ºä¾‹1ï¼šé«˜ä½ä½å¼‚æˆ–è¿ç®— * h=key.hashcode() 1111 1101 1101 1111 0101 1101 0010 1001 * ^ * h &gt;&gt;&gt; 16 0000 0000 0000 0000 1111 1101 1101 1111 * â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” * h ^ (h &gt;&gt;&gt; 16) 1111 1101 1101 1111 1010 0000 1111 0110 * * ç¤ºä¾‹2ï¼šå®šä½å…ƒç´ æ‰€å¤„çš„æ•°ç»„ä½ç½®ï¼ˆå‡è®¾æ­¤æ—¶æ•°ç»„é•¿åº¦=16ï¼‰ * hash 1111 1101 1101 1111 1010 0000 1111 0110 * &amp; * 16-1 0000 0000 0000 0000 0000 0000 0000 1111 * â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” * hash &amp; (16-1) 0000 0000 0000 0000 0000 0000 0000 0110 */static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} >folded comparableClassFor123456789101112131415161718192021222324/** * Returns x's Class if it is of the form &quot;class C implements * Comparable&lt;C&gt;&quot;, else null. * è¿”å› x çš„ class å¦‚æœ x instanceof Comparable * å¦åˆ™è¿”å› null */static Class&lt;?&gt; comparableClassFor(Object x) { if (x instanceof Comparable) { Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) { for (int i = 0; i &lt; ts.length; ++i) { if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; } } } return null;} >folded compareComparables123456789/** * Returns k.compareTo(x) if x matches kc (k's screened comparable * class), else 0. */@SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) // for cast to Comparablestatic int compareComparables(Class&lt;?&gt; kc, Object k, Object x) { return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x));} >folded tableSizeFor ç”Ÿæˆæ•°ç»„é•¿åº¦å€¼12345678910111213/** * Returns a power of two size for the given target capacity. * å¯¹äºç»™å®šçš„ç›®æ ‡å®¹é‡ï¼Œè¿”å›ä¸€ä¸ª2çš„æ¬¡å¹‚çš„å€¼ */static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;} æˆå‘˜å±æ€§>folded table æ•°ç»„123456789101112/* ---------------- Fields -------------- *//** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) * è¯¥tableåœ¨é¦–æ¬¡ä½¿ç”¨æ—¶åˆå§‹åŒ–ï¼Œå¹¶æ ¹æ®éœ€è¦è°ƒæ•´å¤§å°ã€‚ * åˆ†é…æ—¶ï¼Œé•¿åº¦å§‹ç»ˆæ˜¯2çš„å¹‚ã€‚ï¼ˆåœ¨æŸäº›æ“ä½œä¸­ï¼Œæˆ‘ä»¬è¿˜å…è®¸é•¿åº¦ä¸ºé›¶ï¼Œä»¥å…è®¸ä½¿ç”¨å½“å‰ä¸éœ€è¦çš„å¼•å¯¼æœºåˆ¶ã€‚ï¼‰ * transientä¿®é¥°ï¼Œè¯¥å±æ€§å€¼ä¸ä¼šè¢«åºåˆ—åŒ– */transient Node&lt;K,V&gt;[] table; >folded entrySet123456/** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). * ä¿å­˜ç¼“å­˜çš„entrySet() æ³¨æ„ï¼ŒAbstractMapå­—æ®µç”¨äºkeySet()å’Œvalues()ã€‚ */transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; >folded size12345/** * The number of key-value mappings contained in this map. * æ­¤mapä¸­åŒ…å«çš„é”®-å€¼æ˜ å°„æ•°ã€‚ */transient int size; >folded modCount HashMapç»“æ„ä¿®æ”¹æ¬¡æ•°12345678910/** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the HashMap fail-fast. (See ConcurrentModificationException). * å¯¹è¯¥HashMapè¿›è¡Œç»“æ„ä¿®æ”¹çš„æ¬¡æ•°ï¼Œç»“æ„ä¿®æ”¹æ˜¯æŒ‡æ›´æ”¹HashMapä¸­æ˜ å°„æ¬¡æ•°æˆ–ä»¥å…¶ä»–æ–¹å¼ä¿®æ”¹å…¶å†…éƒ¨ç»“æ„ï¼ˆä¾‹å¦‚ï¼Œé‡æ–°å“ˆå¸Œï¼‰çš„ä¿®æ”¹ã€‚ * æ­¤å­—æ®µç”¨äºä½¿HashMapçš„Collection-viewä¸Šçš„è¿­ä»£å™¨å¿«é€Ÿå¤±è´¥ã€‚ ï¼ˆè¯·å‚è§ConcurrentModificationExceptionï¼‰ã€‚ */transient int modCount; >folded threshold12345678910/** * The next size value at which to resize (capacity * load factor). * resizeæ—¶ä¸‹ä¸€ä¸ªå¤§å°çš„å€¼ï¼ˆå®¹é‡ * è´Ÿè½½å› å­ï¼‰ * @serial */// (The javadoc description is true upon serialization.// Additionally, if the table array has not been allocated, this// field holds the initial array capacity, or zero signifying// DEFAULT_INITIAL_CAPACITY.)int threshold; >folded loadFactor è´Ÿè½½å› å­123456/** * The load factor for the hash table. * å“ˆå¸Œè¡¨çš„è´Ÿè½½å› å­ * @serial */final float loadFactor; æˆå‘˜æ–¹æ³•>folded HashMap æ„é€ æ–¹æ³•1ï¼ˆåˆå§‹å®¹é‡ï¼Œè´Ÿè½½å› å­ï¼‰1234567891011121314151617181920212223/* ---------------- Public operations -------------- *//** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);} >folded HashMap æ„é€ æ–¹æ³•2ï¼ˆåˆå§‹å®¹é‡ï¼‰12345678910/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR);} >folded HashMap æ„é€ æ–¹æ³•312345678/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). * é»˜è®¤çš„åˆå§‹å®¹é‡ï¼ˆ16ï¼‰å’Œé»˜è®¤çš„è´Ÿè½½å› å­ï¼ˆ0.75ï¼‰ */public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted} >folded HashMap æ„é€ æ–¹æ³•4ï¼ˆMapç±»å‹å¯¹è±¡ï¼‰12345678910111213/** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);} >folded putMapEntries å°†ä¼ å…¥çš„mapçš„å…ƒç´ å…¨éƒ¨putè¿›å»123456789101112131415161718192021222324252627/** * Implements Map.putAll and Map constructor * å®ç°äº† Map.putAll å’Œ Mapçš„æ„é€ å™¨ * * @param m the map * @param evict false when initially constructing this map, else * true (relayed to method afterNodeInsertion). */final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) { int s = m.size(); if (s &gt; 0) { if (table == null) { // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); } else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); } }} >folded size è¿”å›é”®-å€¼æ˜ å°„æ•°é‡12345678/** * Returns the number of key-value mappings in this map. * * @return the number of key-value mappings in this map */public int size() { return size;} >folded isEmpty è¿”å›æ˜ å°„æ•°æ˜¯å¦ä¸º012345678/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings. * * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings */public boolean isEmpty() { return size == 0;} >folded get æ ¹æ®keyè·å–value123456789101112131415161718192021/** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code (key==null ? k==null : * key.equals(k))}, then this method returns {@code v}; otherwise * it returns {@code null}. (There can be at most one such mapping.) * * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it's also * possible that the map explicitly maps the key to {@code null}. * The {@link #containsKey containsKey} operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;} >folded getNode æ ¹æ®hashå€¼å’Œkeyè·å–NodeèŠ‚ç‚¹ï¼ˆNode/TreeNodeï¼‰1234567891011121314151617181920212223242526/** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null;} >folded containsKey è¿”å›mapæ˜¯å¦åŒ…å«æ­¤é”®1234567891011/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the * specified key. * * @param key The key whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified * key. */public boolean containsKey(Object key) { return getNode(hash(key), key) != null;} >folded put æ”¾å…ƒç´ ï¼ˆkeyï¼Œvalueï¼‰12345678910111213141516/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * å°†æŒ‡å®šå€¼ä¸è¯¥æ˜ å°„ä¸­çš„æŒ‡å®šé”®ç›¸å…³è”ã€‚å¦‚æœè¯¥æ˜ å°„å…ˆå‰åŒ…å«è¯¥é”®çš„æ˜ å°„ï¼Œåˆ™æ›¿æ¢æ—§å€¼ * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */public V put(K key, V value) { return putVal(hash(key), key, value, false, true);} >folded putVal å…·ä½“putæ–¹æ³•çš„å®ç°12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;} >folded resize é‡å»ºtableè¡¨ã€‚åˆå§‹åŒ–æˆ–2å€æ‰©å®¹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab;} >folded treeifyBin æ ‘åŒ–ç»™å®šhashå€¼å¯¹åº”çš„æ¡¶æ‰€æœ‰å…ƒç´ 1234567891011121314151617181920212223242526/** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. * æ ‘åŒ–ç»™å®šhashå€¼å¯¹åº”çš„æ¡¶æ‰€æœ‰å…ƒç´ ï¼Œé™¤étableè¡¨å¤ªå° - tab.length &lt; MIN_TREEIFY_CAPACITYã€‚ * tableè¡¨å¤ªå°çš„æƒ…å†µå°±è¿›è¡Œä¸€éresizeè¡¨é‡å»ºã€‚ */final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) { int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) { TreeNode&lt;K,V&gt; hd = null, tl = null; do { TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); }} >folded putAll å°†ä¼ å…¥çš„mapçš„å…ƒç´ å…¨éƒ¨putè¿›å»1234567891011/** * Copies all of the mappings from the specified map to this map. * These mappings will replace any mappings that this map had for * any of the keys currently in the specified map. * * @param m mappings to be stored in this map * @throws NullPointerException if the specified map is null */public void putAll(Map&lt;? extends K, ? extends V&gt; m) { putMapEntries(m, true);} >folded remove åˆ é™¤æŒ‡å®šé”®çš„æ˜ å°„1234567891011121314/** * Removes the mapping for the specified key from this map if present. * å¦‚æœå­˜åœ¨ï¼Œåˆ™ä»æ­¤mapä¸­åˆ é™¤æŒ‡å®šé”®çš„æ˜ å°„ã€‚ * @param key key whose mapping is to be removed from the map * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */public V remove(Object key) { Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;} >folded removeNode åˆ é™¤æŒ‡å®šé”®çš„èŠ‚ç‚¹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Implements Map.remove and related methods * * @param hash hash for key * @param key the key * @param value the value to match if matchValue, else ignored * @param matchValue if true only remove if value is equal * @param movable if false do not move other nodes while removing * @return the node, or null if none */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) { Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null;} >folded clear åˆ é™¤å…¨éƒ¨é”®å€¼æ˜ å°„12345678910111213/** * Removes all of the mappings from this map. * The map will be empty after this call returns. */public void clear() { Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) { size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; }} >folded containsValue åˆ¤æ–­æ˜¯å¦åŒ…å«æ­¤å€¼123456789101112131415161718192021/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value. * * @param value value whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value */public boolean containsValue(Object value) { Node&lt;K,V&gt;[] tab; V v; if ((tab = table) != null &amp;&amp; size &gt; 0) { for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) { if ((v = e.value) == value || (value != null &amp;&amp; value.equals(v))) return true; } } } return false;} >folded keySet è¿”å›mapåŒ…å«çš„æ‰€æœ‰keyå€¼seté›†åˆ12345678910111213141516171819/** * Returns a {@link Set} view of the keys contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. If the map is modified * while an iteration over the set is in progress (except through * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of * the iteration are undefined. The set supports element removal, * which removes the corresponding mapping from the map, via the * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;, * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; * operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; * operations. * * @return a set view of the keys contained in this map */public Set&lt;K&gt; keySet() { Set&lt;K&gt; ks; return (ks = keySet) == null ? (keySet = new KeySet()) : ks;} KeySetå†…éƒ¨ç±»>folded1234567891011121314151617181920212223242526final class KeySet extends AbstractSet&lt;K&gt; { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator&lt;K&gt; iterator() { return new KeyIterator(); } public final boolean contains(Object o) { return containsKey(o); } public final boolean remove(Object key) { return removeNode(hash(key), key, null, false, true) != null; } public final Spliterator&lt;K&gt; spliterator() { return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer&lt;? super K&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); } if (modCount != mc) throw new ConcurrentModificationException(); } }} >folded values è¿”å›mapä¸­æ‰€æœ‰valueçš„é›†åˆ12345678910111213141516171819/** * Returns a {@link Collection} view of the values contained in this map. * The collection is backed by the map, so changes to the map are * reflected in the collection, and vice-versa. If the map is * modified while an iteration over the collection is in progress * (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), * the results of the iteration are undefined. The collection * supports element removal, which removes the corresponding * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations. It does not * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * @return a view of the values contained in this map */public Collection&lt;V&gt; values() { Collection&lt;V&gt; vs; return (vs = values) == null ? (values = new Values()) : vs;} Valueså†…éƒ¨ç±»>folded1234567891011121314151617181920212223final class Values extends AbstractCollection&lt;V&gt; { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator&lt;V&gt; iterator() { return new ValueIterator(); } public final boolean contains(Object o) { return containsValue(o); } public final Spliterator&lt;V&gt; spliterator() { return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer&lt;? super V&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.value); } if (modCount != mc) throw new ConcurrentModificationException(); } }} >folded entrySet è¿”å›mapåŒ…å«çš„é”®å€¼æ˜ å°„é›†åˆ1234567891011121314151617181920/** * Returns a {@link Set} view of the mappings contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. If the map is modified * while an iteration over the set is in progress (except through * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the * iterator) the results of the iteration are undefined. The set * supports element removal, which removes the corresponding * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and * &lt;tt&gt;clear&lt;/tt&gt; operations. It does not support the * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * @return a set view of the mappings contained in this map */public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;} EntrySetå†…éƒ¨ç±»>folded1234567891011121314151617181920212223242526272829303132333435363738394041final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return new EntryIterator(); } public final boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); } public final boolean remove(Object o) { if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; } return false; } public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() { return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e); } if (modCount != mc) throw new ConcurrentModificationException(); } }} é‡å†™JDK8 Mapæ‰©å±•æ–¹æ³•>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260// Overrides of JDK8 Map extension methods@Overridepublic V getOrDefault(Object key, V defaultValue) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;}@Overridepublic V putIfAbsent(K key, V value) { return putVal(hash(key), key, value, true, true);}@Overridepublic boolean remove(Object key, Object value) { return removeNode(hash(key), key, value, true, true) != null;}@Overridepublic boolean replace(K key, V oldValue, V newValue) { Node&lt;K,V&gt; e; V v; if ((e = getNode(hash(key), key)) != null &amp;&amp; ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) { e.value = newValue; afterNodeAccess(e); return true; } return false;}@Overridepublic V replace(K key, V value) { Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) != null) { V oldValue = e.value; e.value = value; afterNodeAccess(e); return oldValue; } return null;}@Overridepublic V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) { if (mappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) { if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else { Node&lt;K,V&gt; e = first; K k; do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { old = e; break; } ++binCount; } while ((e = e.next) != null); } V oldValue; if (old != null &amp;&amp; (oldValue = old.value) != null) { afterNodeAccess(old); return oldValue; } } V v = mappingFunction.apply(key); if (v == null) { return null; } else if (old != null) { old.value = v; afterNodeAccess(old); return v; } else if (t != null) t.putTreeVal(this, tab, hash, key, v); else { tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); } ++modCount; ++size; afterNodeInsertion(true); return v;}public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) { if (remappingFunction == null) throw new NullPointerException(); Node&lt;K,V&gt; e; V oldValue; int hash = hash(key); if ((e = getNode(hash, key)) != null &amp;&amp; (oldValue = e.value) != null) { V v = remappingFunction.apply(key, oldValue); if (v != null) { e.value = v; afterNodeAccess(e); return v; } else removeNode(hash, key, null, false, true); } return null;}@Overridepublic V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) { if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) { if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else { Node&lt;K,V&gt; e = first; K k; do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { old = e; break; } ++binCount; } while ((e = e.next) != null); } } V oldValue = (old == null) ? null : old.value; V v = remappingFunction.apply(key, oldValue); if (old != null) { if (v != null) { old.value = v; afterNodeAccess(old); } else removeNode(hash, key, null, false, true); } else if (v != null) { if (t != null) t.putTreeVal(this, tab, hash, key, v); else { tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); } ++modCount; ++size; afterNodeInsertion(true); } return v;}@Overridepublic V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) { if (value == null) throw new NullPointerException(); if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) { if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else { Node&lt;K,V&gt; e = first; K k; do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { old = e; break; } ++binCount; } while ((e = e.next) != null); } } if (old != null) { V v; if (old.value != null) v = remappingFunction.apply(old.value, value); else v = value; if (v != null) { old.value = v; afterNodeAccess(old); } else removeNode(hash, key, null, false, true); return v; } if (value != null) { if (t != null) t.putTreeVal(this, tab, hash, key, value); else { tab[i] = newNode(hash, key, value, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); } ++modCount; ++size; afterNodeInsertion(true); } return value;}@Overridepublic void forEach(BiConsumer&lt;? super K, ? super V&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key, e.value); } if (modCount != mc) throw new ConcurrentModificationException(); }}@Overridepublic void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) { Node&lt;K,V&gt;[] tab; if (function == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) { e.value = function.apply(e.key, e.value); } } if (modCount != mc) throw new ConcurrentModificationException(); }} clone å’Œ åºåˆ—åŒ–æ–¹æ³•>folded clone123456789101112131415161718192021222324/* ------------------------------------------------------------ */// Cloning and serialization/** * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and * values themselves are not cloned. * è¿”å›æ­¤HashMapå®ä¾‹çš„æµ…å‰¯æœ¬ï¼šé”®å’Œå€¼æœ¬èº«ä¸ä¼šè¢«å…‹éš†ã€‚ * * @return a shallow copy of this map */@SuppressWarnings(&quot;unchecked&quot;)@Overridepublic Object clone() { HashMap&lt;K,V&gt; result; try { result = (HashMap&lt;K,V&gt;)super.clone(); } catch (CloneNotSupportedException e) { // this shouldn't happen, since we are Cloneable throw new InternalError(e); } result.reinitialize(); result.putMapEntries(this, false); return result;} >folded serialization ç”¨äºåºåˆ—åŒ–çš„ä¸€äº›æ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// These methods are also used when serializing HashSetsfinal float loadFactor() { return loadFactor; }final int capacity() { return (table != null) ? table.length : (threshold &gt; 0) ? threshold : DEFAULT_INITIAL_CAPACITY;}/** * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e., * serialize it). * å°†HashMapå®ä¾‹çš„çŠ¶æ€ä¿å­˜åˆ°æµä¸­ï¼ˆå³åºåˆ—åŒ–å®ƒï¼‰ã€‚ * * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the * bucket array) is emitted (int), followed by the * &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value * mappings), followed by the key (Object) and value (Object) * for each key-value mapping. The key-value mappings are * emitted in no particular order. */private void writeObject(java.io.ObjectOutputStream s) throws IOException { int buckets = capacity(); // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); s.writeInt(buckets); s.writeInt(size); internalWriteEntries(s);}/** * Reconstitute the {@code HashMap} instance from a stream (i.e., * deserialize it). * ä»æµä¸­é‡å»ºHashMapå®ä¾‹ï¼ˆå³ååºåˆ—åŒ–å®ƒï¼‰ã€‚ */private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) { // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) { @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } }} iterators è¿­ä»£æ–¹æ³•>folded HashIterator hashè¿­ä»£å™¨æŠ½è±¡å†…éƒ¨ç±»123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* ------------------------------------------------------------ */// iteratorsabstract class HashIterator { Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() { expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) { // advance to first entry do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); } } public final boolean hasNext() { return next != null; } final Node&lt;K,V&gt; nextNode() { Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) { do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); } return e; } public final void remove() { Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount; }} >folded HashIteratorçš„ä¸‰ä¸ªå­ç±»ï¼škeyã€valueã€æ˜ å°„è¿­ä»£å™¨1234567891011121314final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; { public final K next() { return nextNode().key; }}final class ValueIterator extends HashIterator implements Iterator&lt;V&gt; { public final V next() { return nextNode().value; }}final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; { public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }} spliterators åˆ†ç¦»å™¨>folded HashMapSpliteratoråˆ†ç¦»å™¨é™æ€å†…éƒ¨ç±»1234567891011121314151617181920212223242526272829303132333435363738/* ------------------------------------------------------------ */// spliteratorsstatic class HashMapSpliterator&lt;K,V&gt; { final HashMap&lt;K,V&gt; map; Node&lt;K,V&gt; current; // current node | å½“å‰èŠ‚ç‚¹ int index; // current index, modified on advance/split | å½“å‰ç´¢å¼•ï¼Œåœ¨ advance/split æ—¶ä¿®æ”¹ int fence; // one past last index | æœ€åä¸€ä¸ªç´¢å¼• int est; // size estimate | é¢„ä¼°å¤§å° int expectedModCount; // for comodification checks | é¢„æœŸä¿®æ”¹æ•°ï¼Œç”¨äºä¿®æ”¹æ£€æŸ¥ HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) { this.map = m; this.index = origin; this.fence = fence; this.est = est; this.expectedModCount = expectedModCount; } final int getFence() { // initialize fence and size on first use | ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶åˆå§‹åŒ–fenceå’Œestã€expectedModCount int hi; if ((hi = fence) &lt; 0) { HashMap&lt;K,V&gt; m = map; est = m.size; expectedModCount = m.modCount; Node&lt;K,V&gt;[] tab = m.table; hi = fence = (tab == null) ? 0 : tab.length; } return hi; } public final long estimateSize() { getFence(); // force init return (long) est; }} >folded KeySpliteratoråˆ†ç¦»å™¨1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071static final class KeySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;K&gt; { KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) { super(m, origin, fence, est, expectedModCount); } public KeySpliterator&lt;K,V&gt; trySplit() { int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); } public void forEachRemaining(Consumer&lt;? super K&gt; action) { int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) { mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; } else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) { Node&lt;K,V&gt; p = current; current = null; do { if (p == null) p = tab[i++]; else { action.accept(p.key); p = p.next; } } while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); } } public boolean tryAdvance(Consumer&lt;? super K&gt; action) { int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) { while (current != null || index &lt; hi) { if (current == null) current = tab[index++]; else { K k = current.key; current = current.next; action.accept(k); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } } } return false; } public int characteristics() { return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; }} >folded ValueSpliteratoråˆ†ç¦»å™¨12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static final class ValueSpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;V&gt; { ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) { super(m, origin, fence, est, expectedModCount); } public ValueSpliterator&lt;K,V&gt; trySplit() { int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); } public void forEachRemaining(Consumer&lt;? super V&gt; action) { int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) { mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; } else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) { Node&lt;K,V&gt; p = current; current = null; do { if (p == null) p = tab[i++]; else { action.accept(p.value); p = p.next; } } while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); } } public boolean tryAdvance(Consumer&lt;? super V&gt; action) { int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) { while (current != null || index &lt; hi) { if (current == null) current = tab[index++]; else { V v = current.value; current = current.next; action.accept(v); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } } } return false; } public int characteristics() { return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0); }} >folded EntrySpliteratoråˆ†ç¦»å™¨1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071static final class EntrySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; { EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) { super(m, origin, fence, est, expectedModCount); } public EntrySpliterator&lt;K,V&gt; trySplit() { int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); } public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) { int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) { mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; } else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) { Node&lt;K,V&gt; p = current; current = null; do { if (p == null) p = tab[i++]; else { action.accept(p); p = p.next; } } while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); } } public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) { int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) { while (current != null || index &lt; hi) { if (current == null) current = tab[index++]; else { Node&lt;K,V&gt; e = current; current = current.next; action.accept(e); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } } } return false; } public int characteristics() { return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; }} LinkedHashMap support LinkedHashMapæ”¯æŒ>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* ------------------------------------------------------------ */// LinkedHashMap support/* * The following package-protected methods are designed to be * overridden by LinkedHashMap, but not by any other subclass. * Nearly all other internal methods are also package-protected * but are declared final, so can be used by LinkedHashMap, view * classes, and HashSet. * ä¸‹é¢çš„å—ç¨‹åºåŒ…ä¿æŠ¤çš„æ–¹æ³•æ—¨åœ¨è¢«LinkedHashMapè¦†ç›–ï¼Œä½†ä¸èƒ½è¢«ä»»ä½•å…¶ä»–å­ç±»è¦†ç›–ã€‚ * å‡ ä¹æ‰€æœ‰å…¶ä»–å†…éƒ¨æ–¹æ³•ä¹Ÿå—ç¨‹åºåŒ…ä¿æŠ¤ï¼Œä½†éƒ½å£°æ˜ä¸ºfinalï¼Œå› æ­¤LinkedHashMapï¼Œè§†å›¾ç±»å’ŒHashSetå¯ä»¥ä½¿ç”¨å®ƒã€‚ */// Create a regular (non-tree) node | åˆ›å»ºä¸€ä¸ªå¸¸è§„ï¼ˆéæ ‘ï¼‰èŠ‚ç‚¹Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) { return new Node&lt;&gt;(hash, key, value, next);}// For conversion from TreeNodes to plain nodes | ç”¨äºä»TreeNodesè½¬æ¢ä¸ºå¸¸è§„èŠ‚ç‚¹Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) { return new Node&lt;&gt;(p.hash, p.key, p.value, next);}// Create a tree bin node | åˆ›å»ºä¸€ä¸ªæ ‘èŠ‚ç‚¹TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) { return new TreeNode&lt;&gt;(hash, key, value, next);}// For treeifyBin | è½¬åŒ–ä¸ºæ ‘èŠ‚ç‚¹TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) { return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);}/** * Reset to initial default state. Called by clone and readObject. * é‡ç½®ä¸ºåˆå§‹é»˜è®¤çŠ¶æ€ã€‚ ç”±cloneå’ŒreadObjectè°ƒç”¨ */void reinitialize() { table = null; entrySet = null; keySet = null; values = null; modCount = 0; threshold = 0; size = 0;}// Callbacks to allow LinkedHashMap post-actions | å…è®¸LinkedHashMapåå¤„ç†çš„å›è°ƒvoid afterNodeAccess(Node&lt;K,V&gt; p) { }void afterNodeInsertion(boolean evict) { }void afterNodeRemoval(Node&lt;K,V&gt; p) { }// Called only from writeObject, to ensure compatible ordering. | ä»…ä»writeObjectè°ƒç”¨ï¼Œä»¥ç¡®ä¿å…¼å®¹çš„é¡ºåºã€‚void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException { Node&lt;K,V&gt;[] tab; if (size &gt; 0 &amp;&amp; (tab = table) != null) { for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) { s.writeObject(e.key); s.writeObject(e.value); } } }} Tree bins æ ‘ç®±>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612/* ------------------------------------------------------------ */// Tree bins/** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. * æ ‘ç®±çš„Entryã€‚ ç»§æ‰¿LinkedHashMap.Entryï¼ˆè¿›è€Œæ‰©å±•Nodeï¼‰ï¼Œå› æ­¤å¯ä»¥ç”¨ä½œå¸¸è§„èŠ‚ç‚¹æˆ–é“¾æ¥èŠ‚ç‚¹çš„æ‰©å±•ã€‚ */static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; { TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) { super(hash, key, val, next); } /** * Returns root of tree containing this node. * è¿”å›åŒ…å«æ­¤èŠ‚ç‚¹çš„æ ‘çš„æ ¹èŠ‚ç‚¹ */ final TreeNode&lt;K,V&gt; root() { for (TreeNode&lt;K,V&gt; r = this, p;;) { if ((p = r.parent) == null) return r; r = p; } } /** * Ensures that the given root is the first node of its bin. * ç¡®ä¿ç»™å®šçš„æ ¹æ˜¯å…¶binçš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ */ static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) { int n; if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) { int index = (n - 1) &amp; root.hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; if (root != first) { Node&lt;K,V&gt; rn; tab[index] = root; TreeNode&lt;K,V&gt; rp = root.prev; if ((rn = root.next) != null) ((TreeNode&lt;K,V&gt;)rn).prev = rp; if (rp != null) rp.next = rn; if (first != null) first.prev = root; root.next = first; root.prev = null; } assert checkInvariants(root); } } /** * Finds the node starting at root p with the given hash and key. * The kc argument caches comparableClassFor(key) upon first use * comparing keys. * æ ¹æ®ç»™å®šçš„hashå’Œkey ä»æ ‘æ ¹èŠ‚ç‚¹på¼€å§‹æŸ¥æ‰¾è¯¥èŠ‚ç‚¹ã€‚ * kcå‚æ•°åœ¨é¦–æ¬¡æ¯”è¾ƒkeyæ—¶ä¼šç¼“å­˜comparableClassFor(key) */ final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) { TreeNode&lt;K,V&gt; p = this; do { int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; } while (p != null); return null; } /** * Calls find for root node. * è°ƒç”¨æŸ¥æ‰¾æ ¹èŠ‚ç‚¹ã€‚ */ final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) { return ((parent != null) ? root() : this).find(h, k, null); } /** * Tie-breaking utility for ordering insertions when equal * hashCodes and non-comparable. We don't require a total * order, just a consistent insertion rule to maintain * equivalence across rebalancings. Tie-breaking further than * necessary simplifies testing a bit. * Tie-breakingç¨‹åºï¼Œç”¨äºåœ¨hashCodesç›¸ç­‰ä¸”ä¸å¯æ¯”è¾ƒæ—¶å¯¹æ’å…¥è¿›è¡Œæ’åºã€‚ * æˆ‘ä»¬ä¸éœ€è¦æ€»çš„æ’åºï¼Œåªéœ€ä¸€ä¸ªä¸€è‡´çš„æ’å…¥è§„åˆ™å³å¯åœ¨é‡æ–°å¹³è¡¡æœŸé—´ä¿æŒç­‰æ•ˆã€‚ * Tie-breakingæ¯”ç®€åŒ–æµ‹è¯•æ›´æœ‰å¿…è¦ã€‚ */ static int tieBreakOrder(Object a, Object b) { int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d; } /** * Forms tree of the nodes linked from this node. * ä»è¯¥èŠ‚ç‚¹é“¾æ¥çš„èŠ‚ç‚¹çš„è¡¨å•æ ‘ã€‚- æ ‘åŒ–èŠ‚ç‚¹ï¼šéæ ‘èŠ‚ç‚¹ -&gt; æ ‘èŠ‚ç‚¹ * @return root of tree */ final void treeify(Node&lt;K,V&gt;[] tab) { TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) { next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) { x.parent = null; x.red = false; root = x; } else { K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = root;;) { int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) { x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; } } } } moveRootToFront(tab, root); } /** * Returns a list of non-TreeNodes replacing those linked from * this node. * è¿”å›éTreeNodeåˆ—è¡¨ï¼Œè¯¥åˆ—è¡¨æ›¿æ¢ä»è¯¥èŠ‚ç‚¹é“¾æ¥çš„éTreeNodeã€‚- å»æ ‘åŒ–ï¼šæ ‘èŠ‚ç‚¹ -&gt; éæ ‘èŠ‚ç‚¹ */ final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) { Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) { Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; } return hd; } /** * Tree version of putVal. */ final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) { Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) { int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) { if (!searched) { TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; } dir = tieBreakOrder(k, pk); } TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) { Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; } } } /** * Removes the given node, that must be present before this call. * This is messier than typical red-black deletion code because we * cannot swap the contents of an interior node with a leaf * successor that is pinned by &quot;next&quot; pointers that are accessible * independently during traversal. So instead we swap the tree * linkages. If the current tree appears to have too few nodes, * the bin is converted back to a plain bin. (The test triggers * somewhere between 2 and 6 nodes, depending on tree structure). * åˆ é™¤ç»™å®šèŠ‚ç‚¹å¿…é¡»åœ¨æ­¤è°ƒç”¨ä¹‹å‰ã€‚ * è¿™æ¯”å…¸å‹çš„çº¢é»‘æ ‘åˆ é™¤ä»£ç æ›´ä¸ºæ··ä¹±ï¼Œå› ä¸ºæˆ‘ä»¬ä¸èƒ½å°†å†…éƒ¨èŠ‚ç‚¹çš„å†…å®¹ä¸å¶ç»§æ‰¿è€…äº¤æ¢ï¼Œå¶ç»§æ‰¿è€…æ˜¯ç”±åœ¨éå†æœŸé—´å¯ç‹¬ç«‹è®¿é—®çš„â€œä¸‹ä¸€ä¸ªâ€æŒ‡é’ˆå›ºå®šçš„ã€‚ * å› æ­¤ï¼Œæˆ‘ä»¬äº¤æ¢æ ‘é“¾æ¥ã€‚å¦‚æœå½“å‰æ ‘çš„èŠ‚ç‚¹ä¼¼ä¹å¤ªå°‘ï¼Œåˆ™å°†æ ‘ç®±è½¬æ¢å›æ™®é€šç®±ã€‚ ï¼ˆè¯¥æµ‹è¯•è§¦å‘åœ¨2åˆ°6ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„æŸä¸ªä½ç½®ï¼Œå…·ä½“å–å†³äºæ ‘çš„ç»“æ„ï¼‰ã€‚ */ final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) { int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) &amp; hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); if (root == null || root.right == null || (rl = root.left) == null || rl.left == null) { tab[index] = first.untreeify(map); // too small return; } TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) { TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor | æŸ¥æ‰¾ç»§ä»»è€… s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors | äº¤æ¢é¢œè‰² TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; if (s == pr) { // p was s's direct parent | pæ˜¯sçš„ç›´æ¥çˆ¶çº§ p.parent = s; s.right = p; } else { TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) { if (s == sp.left) sp.left = p; else sp.right = p; } if ((s.right = pr) != null) pr.parent = s; } p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; } else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) { TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; } TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) { // detach | åˆ†ç¦» TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) { if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; } } if (movable) moveRootToFront(tab, r); } /** * Splits nodes in a tree bin into lower and upper tree bins, * or untreeifies if now too small. Called only from resize; * see above discussion about split bits and indices. * å°†æ ‘ç®±ä¸­çš„èŠ‚ç‚¹æ‹†åˆ†ä¸ºè¾ƒé«˜å’Œè¾ƒä½çš„æ ‘ç®±ï¼Œå¦‚æœç°åœ¨å¤ªå°ï¼Œåˆ™å–æ¶ˆæ ‘åŒ–ã€‚ä»…è¢«resizeè°ƒç”¨ï¼› * è¯·å‚é˜…ä¸Šé¢æœ‰å…³æ‹†åˆ†ä½å’Œç´¢å¼•çš„è®¨è®ºã€‚ * * @param map the map * @param tab the table for recording bin heads * @param index the index of the table being split * @param bit the bit of hash to split on */ final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) { TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order | é‡æ–°é“¾æ¥åˆ°loå’Œhiåˆ—è¡¨ï¼Œä¿ç•™é¡ºåº TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) { next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) { if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; } else { if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; } } if (loHead != null) { if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else { tab[index] = loHead; if (hiHead != null) // (else is already treeified) | å…¶ä»–å·²ç»è¢«æ ‘åŒ–äº† loHead.treeify(tab); } } if (hiHead != null) { if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else { tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); } } } /* ------------------------------------------------------------ */ // Red-black tree methods, all adapted from CLR | çº¢é»‘æ ‘æ–¹æ³•ï¼Œå…¨éƒ¨æ”¹ç¼–è‡ªCLR static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) { TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) { if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; } return root; } static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) { TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) { if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; } return root; } static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) { x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) { if ((xp = x.parent) == null) { x.red = false; return x; } else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) { if ((xppr = xpp.right) != null &amp;&amp; xppr.red) { xppr.red = false; xp.red = false; xpp.red = true; x = xpp; } else { if (x == xp.right) { root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; } if (xp != null) { xp.red = false; if (xpp != null) { xpp.red = true; root = rotateRight(root, xpp); } } } } else { if (xppl != null &amp;&amp; xppl.red) { xppl.red = false; xp.red = false; xpp.red = true; x = xpp; } else { if (x == xp.left) { root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; } if (xp != null) { xp.red = false; if (xpp != null) { xpp.red = true; root = rotateLeft(root, xpp); } } } } } } static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) { for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) { if (x == null || x == root) return root; else if ((xp = x.parent) == null) { x.red = false; return x; } else if (x.red) { x.red = false; return root; } else if ((xpl = xp.left) == x) { if ((xpr = xp.right) != null &amp;&amp; xpr.red) { xpr.red = false; xp.red = true; root = rotateLeft(root, xp); xpr = (xp = x.parent) == null ? null : xp.right; } if (xpr == null) x = xp; else { TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) { xpr.red = true; x = xp; } else { if (sr == null || !sr.red) { if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; } if (xpr != null) { xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; } if (xp != null) { xp.red = false; root = rotateLeft(root, xp); } x = root; } } } else { // symmetric | å¯¹ç§°çš„ if (xpl != null &amp;&amp; xpl.red) { xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; } if (xpl == null) x = xp; else { TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) { xpl.red = true; x = xp; } else { if (sl == null || !sl.red) { if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; } if (xpl != null) { xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; } if (xp != null) { xp.red = false; root = rotateRight(root, xp); } x = root; } } } } } /** * Recursive invariant check * é€’å½’ä¸å˜æ£€æŸ¥ */ static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) { TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right, tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next; if (tb != null &amp;&amp; tb.next != t) return false; if (tn != null &amp;&amp; tn.prev != t) return false; if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right) return false; if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash)) return false; if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash)) return false; if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red) return false; if (tl != null &amp;&amp; !checkInvariants(tl)) return false; if (tr != null &amp;&amp; !checkInvariants(tr)) return false; return true; }}","link":"/2020/10/15/source_code/lock/"}],"tags":[{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"UDP","slug":"UDP","link":"/tags/UDP/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"birthday","slug":"birthday","link":"/tags/birthday/"},{"name":"jdkæºç ","slug":"jdkæºç ","link":"/tags/jdk%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"è®¡ç®—æœºç½‘ç»œ","slug":"è®¡ç®—æœºç½‘ç»œ","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"test","slug":"test","link":"/categories/test/"},{"name":"my-life","slug":"my-life","link":"/categories/my-life/"},{"name":"birthday","slug":"my-life/birthday","link":"/categories/my-life/birthday/"},{"name":"jdkæºç ç¿»è¯‘","slug":"jdkæºç ç¿»è¯‘","link":"/categories/jdk%E6%BA%90%E7%A0%81%E7%BF%BB%E8%AF%91/"}]}